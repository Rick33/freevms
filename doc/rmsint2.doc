






                                  A Brief Overview

                                         of

                                  RMS-11 Internals

                                         by

                               Phil Stephensen-Payne

                                 c/o Systime Ltd.,
                                 432 Dewsbury Road,
                                  LEEDS LS11 7DF,
                                      England.
                                 Tel: (0532)-702211

                                   October 1980.


         RMS-11 Internals                                              Page 2





                                    ____________                                    INTRODUCTION

                 RMS-11  forms  a  very important part of many applications
                 and  systems  on PDP-11 processors running RSX-11M, RSTS/E
                 or VMS and yet there seems to be very little documentation
                 on the internals of the file system, particularly compared
                 with  the  wealth  of  information  available on its older
                 cousin FCS.  While the new documentation that was released
                 with  RMS-11  V1.8  is  vastly  superior  to that provided
                 previously,  it  still does not contain enough information
                 for  the  user to determine exactly what the format of his
                 files  on  disk  is, or even exactly how much space in his
                 program  is  required.  This document aims to fill in some
                 of  those  gaps  (with emphasis on RSX-11M) and to provide
                 enough  basic  information for the interested user to work
                 from.

                 The  information  for this document has been garnered from
                 six places:-

                 a)      RMS-11  User's Guide, No. AA-D538A-TC, dated March
                         1979.
                 b)      RMS-11 Macro-11 Reference Manual, No. AA-H683A-TC,
                         dated March 1979.
                 c)      RMS-11 Design & Logic Manual dated July 1977.
                 d)      The   macros   supplied   with   RMS-11   V1.8  in
                         RMSMAC.MLB.
                 e)      Dumps of various test files.
                 f)      The RMS-11 Prototype ODL file RMS11.ODL.

                 In  general  information contained adequately in the first
                 two  (hereafter  referred  to  as  RUG  & RMR) will not be
                 repeated  on  the assumption that every user has access to
                 them.    Odd  pieces  of information garnered from c) & d)
                 have  been  included  even  when  I  am unsure as to their
                 meaning or relevance.

                 The document is divided into five major sections with four
                 appendices  at  the  end  amplifying  and illustrating the
                 preceding material:-

                 Chapter I.   RMS-11 File Layouts.
                 Chapter II.  RMS-11 In-Core Table Layouts.
                 Chapter III. RMS-11 Macros.
                 Chapter IV.  RMS-11 Subroutines.
                 Chapter V.   RMSBCK/RMSRST Tape Formats.
                 Appendix A.  Formatted Dump of an RMS-11 Indexed File.
                 Appendix B.  Some additional RMS-11 Design/Logic points.
                 Appendix C.  Some    RMS-11   Design/Logic   Algoritms   &
                              Flowcharts.
                 Appendix D.  RMS-11 Mnemonic Glossary.


         RMS-11 Internals                                              Page 3





                                     _______                                       CHAPTER I

                                ___________________                                RMS-11 File Layouts

                 ___________         a)      File Header

                 RMS-11  uses  a  slightly modified version of the standard
                 FCS  File  Header.   The area that is affected is the User
                 File  Attributes  section  (H.UFAT).   This is defined for
                 RMS-11  files  as  follows (note that the symbolic offsets
                 are  actually  defined  with  respect  to  the  IFABs [see
                 Chapter  II]  and  only  their  relative  values are valid
                 here):-

                                ___________________                                RMS File Attributes

         (Offsets defined in IFAOF$, bit values in FAB$BT)
                       !-----------------------------------------!
         F$FORG/F$RATT ! Record Attributes  !    File Format     !
                       !-----------------------------------------!
         F$RSIZ        !               Record Size               !
                       !-----------------------------------------!
         F$HVBN        !               High Block                !
                       !-----                               -----!
         F$LVBN        !                   VBN                   !
                       !-----------------------------------------!
         F$HEOF        !            End-of-File Block            !
                       !-----                               -----!
         F$LEOF        !                   VBN                   !
                       !-----------------------------------------!
         F$FFBY        !             First Free Byte             !
                       !-----------------------------------------!
         F$BKSZ/F$HDSZ !  VFC Header Size   !Largest Bucket Size !
                       !-----------------------------------------!
         F$MRS         !           Maximum Record Size           !
                       !-----------------------------------------!
         F$DEQ         !   Default Extend Allocation Quantity    !
                       !-----------------------------------------!

                 Bits Defined in F$FORG (byte)

                 +------------------------------+
                 !   !   !FB$!FB$!    Record    !
                 !   !   !IDX!REL!    Format    !
                 +------------------------------+

                 Record Format:
                 FB$UDF =   0 = Undefined Format (Block I/O only)
                 FB$FIX =   1 = Fixed Length Records (=R.FIX)
                 FB$VAR =   2 = Variable Length Records (=R.VAR)
                 FB$VFC =   3 = VFC records (=R.SEQ)
                 FB$STM =   4 = Stream Format


         RMS-11 Internals                                              Page 4





                 File Organisations:
                 FB$SEQ =   0 = Sequential File
                 FB$REL =  20 = Relative File
                 FB$IDX =  40 = Indexed File

                 Bits Defined in F$RATT (byte)

                 +-------------------------------+
                 !   !   !   !   !FB$!FB$!FB$!FB$!
                 !   !   !   !   !BLK!PRN!CR !FTN!
                 +-------------------------------+

                 FB$FTN =   1 = Use Fortran Carriage Control. (=FD.FTN)
                 FB$CR  =   2 = Use implied Carriage Control (=FD.CR)
                 FB$PRN  =   4 = Interpret first two bytes of fixed control
                                area of VFC record as Carriage Control (See
                                Appendix B)
                 FB$BLK  =    10  =  Records  do not cross block boundaries
                                (=FD.BLK)

                 F$RSIZ,  for  Sequential Files, is identical to the F.RSIZ
                     field  under  FCS.  For Indexed & Relative Files it is
                     also  so  defined  for  fixed-length  records,  but is
                     undefined for variable-length (or VFC) records.
                 F$HVBN  &  F$HEOF have the same meaning as F.HIBK & F.EFBK
                     under  FCS, but as RMS only maintains these fields for
                     compatibility purposes there is no guarantee that they
                     will  always  be  as  expected  for Relative & Indexed
                     Files.
                 F$FFBY  has  the  same  meaning  as  F.FFBY  under FCS for
                     Sequential  Files but is undefined (probably 0 or 512)
                     for Relative or Indexed Files.
                 F$BKSZ contains the Bucket Size (or Maximum Bucket Size if
                     several  are  defined) for Indexed and Relative Files.
                     (See RMR 3-6.)
                 F$HDSZ  contains  the number of bytes (0-255) in the fixed
                     control area of VFC records, where 0 is interpreted as
                     2 for compatibility with FCS R.SEQ type records.
                     This  field also seems to be set to 2 in Indexed Files
                     (which  cannot  have  VFC  records)  once the Index is
                     initialized.
                 F$MRS contains the user-specified Maximum Record Size (see
                     RMR 3-38)
                 F$DEQ  contains the file Default Extend Quantity in blocks
                     (see RMR 3-17)

         RMS-11 Internals                                              Page 5





                 ________________         b)      Sequential Files

                 Other than File Header differences just discussed there is
                 no   difference  between  FCS  Sequential  Files  and  RMS
                 Sequential  Files  (apart  for  the record types VFC & STM
                 supported  by RMS but not by FCS) which is why they can be
                 referenced interchangeably from one to the other.

         RMS-11 Internals                                              Page 6





                 ______________         c)      Relative Files

                 As  discussed  in  RUG (4-1) a Relative File starts with a
                 Prologue  Block (which will be extended to the bucket size
                 if  that  is  2,  4 or 8 blocks).  This block contains the
                 following information:-

                           _____________________________                           Relative Files Prologue Block

         (Offsets defined in KDXOF$, Bit Values in KDX$BT)
                       !-----------------------------------------!
                       !                Spare                    !   0
                       .              (5 words)                  .
                       .                                         .
                       !-----------------------------------------!
               /P$DBKS !  Data Bucket Size  !                    !  12
                       !-----------------------------------------!
                       !                Spare                    !  14
                       !-----------------------------------------!
                       !                Spare                    !  16
                       !-----------------------------------------!
         P$FLGS/       !                    !       Flags        !  20
                       !-----------------------------------------!
                       !                Spare                    !  22
                       .             (43. words)                 .
                       .                                         .
                       !-----------------------------------------!
         P$DVBN        !             1st Data Bucket             ! 150
                       !-----                               -----!
         P$DVB2        !                   VBN                   ! 152
                       !-----------------------------------------!
         P$LMRN        !             Maximum Record              ! 154
                       !-----                               -----!
         P$HMRN        !                 Number                  ! 156
                       !-----------------------------------------!
         P$LEOF        !            End-of-File Block            ! 160
                       !-----                               -----!
         P$HEOF        !                   VBN                   ! 162
                       !-----------------------------------------!
         P$VERN        !         Prologue Version Number         ! 164
                       !-----------------------------------------!
                       !                Spare                    ! 166
                       .             (196. words)                .
                       .                                         .
                       !-----------------------------------------!
                       !            Prologue Checksum            ! 776
                       !-----------------------------------------!


         RMS-11 Internals                                              Page 7





                 Bits Defined in P$FLGS (byte)

                 +-------------------------------+
                 !   !   !   !   !   !   !   !PR$!
                 !   !   !   !   !   !   !   !NEX!
                 +-------------------------------+

                 PR$NEX =  1 = Error  encountered extending relative File -
                               No Further Extension possible

                 P$DBKS  contains  the  bucket size (in blocks) of the file
                     (see RMR 3-6)
                 P$DVBN/P$DVB2  contain  the  32-bit  VBN of the first data
                     bucket in the file.
                 P$LMRN/P$HMRN  contain  the  user-specified Maximum Record
                     Number (see RMR 3-36)
                 P$LEOF/P$HEOF  contain  the  last  initialized  VBN of the
                     Relative File.
                 P$VERN contains the Prologue Version Number (see RMR 5-78)

                 The  Prologue Checksum is defined in the normal manner for
                 Files-11,  i.e. it contains the sum of the contents of the
                 other 255 words (ignoring overflow).

                 The cells in a Relative File are defined in RUG (4-1).
                 The  control  byte  contains  the  following  bits (values
                 defined in BKT$BT) :-

                 +-------------------------------+
                 !   !   !   !   !DC$!DC$!   !   !
                 !   !   !   !   !REC!DEL!   !   !
                 +-------------------------------+

                 DC$DEL =   4 = Record has been deleted
                 DC$REC =  10 = Record exists

                 A  value  of  zero  in the control byte indicates that the
                 cell has never contained a record.

         RMS-11 Internals                                              Page 8





                 ________________________         d)      Indexed Files - Prologue

                 As  discussed  in  RUG  (5-2  &  6-24)  each  Indexed File
                 contains  a  Prologue  consisting of Key Descriptor Blocks
                 and  Area Descriptor Blocks.  The Primary Key is described
                 in  the  first  block, then all further keys (5 per block)
                 are described and then all areas (8 per block).

                 The  first  Prologue  Block (containing the key descriptor
                 for the primary key) is laid out as follows:-

                           _____________________________                           Indexed File Prologue Block 1

         (Offsets defined in KDXOF$, bit values in KDX$BT)
                       !-----------------------------------------!
         K$NLVB        !           Next Key Descriptor           !   0
                       !-----                               -----!
         K$NHVB        !                   VBN                   !   2
                       !-----------------------------------------!
         K$NBYT        !    Byte Position of Next Descriptor     !   4
                       !-----------------------------------------!
         K$IAN /K$LAN  !Low Level Index Area! Index Area Number  !   6
                       !-----------------------------------------!
         K$DAN /K$LVL  !  Root Index Level  !  Data Area Number  !  10
                       !-----------------------------------------!
         K$IBKS/K$DBKS !  Data Bucket Size  ! Index Bucket Size  !  12
                       !-----------------------------------------!
         K$LVBN        !               Root Bucket               !  14
                       !-----                               -----!
         K$HVBN        !                   VBN                   !  16
                       !-----------------------------------------!
         K$FLGS/K$DTP  !   Key Data Type    !       Flags        !  20
                       !-----------------------------------------!
         K$NSEG/K$NULL !   Null Key Char    !  No. Key Segments  !  22
                       !-----------------------------------------!
         K$KYSZ/K$KEY  !  Key of Reference  !   Total Key Size   !  24
                       !-----------------------------------------!
         K$MINL        !    Minimum Record Length Holding Key    !  26
                       !-----------------------------------------!
         K$IFIL        !   Index Bucket Fill Quantity (bytes)    !  30
                       !-----------------------------------------!
         K$DFIL        !    Data Bucket Fill Quantity (bytes)    !  32
                       !-----------------------------------------!
         K$POS         !                                         !  34
         K$POS0        !-----                               -----!
                       !                   Key                   !  36
           !           !-----                               -----!
           V           !                                         !  40
                       !-----                               -----!
         K$POS7        !                 Segment                 !  42
                       !-----                               -----!
                       !                                         !  44
                       !-----                               -----!
                       !                Positions                !  46

         RMS-11 Internals                                              Page 9





                       !-----                               -----!
                       !                                         !  50
                       !-----                               -----!
                       !                                         !  52
                       !-----------------------------------------!
         K$SIZ         !                   Key                   !  54
         K$SIZ0        !-----                               -----!
                       !                 Segment                 !  56
           !           !-----                               -----!
           V           !                  Sizes                  !  60
                       !-----                               -----!
         K$SIZ7        !                                         !  62
                       !-----------------------------------------!
         K$KNM         !                   Key                   !  64
                       !-----                               -----!
                       !                  Name                   !
                       !-----                               -----!
                       .               (32 bytes)                .
                       .                                         .
                       !-----------------------------------------!
         K$LDVB        !             1st Data Bucket             ! 124
                       !-----                               -----!
         K$HDVB        !                   VBN                   ! 126
                       !-----------------------------------------!
                       !             Spare (7 words)             ! 130
                       .                                         .
                       .                                         .
                       !-----------------------------------------!
         P$AVBN/P$AMAX !  No. of Areas + 1  !  VBN of 1st Area   ! 146
                       !-----------------------------------------!
                       !             Spare (6 words)             ! 150
                       .                                         .
                       .                                         .
                       !-----------------------------------------!
         P$VERN        !         Prologue Version Number         ! 164
                       !-----------------------------------------!
                       !                Spare                    ! 166
                       .             (196. words)                .
                       .                                         .
                       !-----------------------------------------!
                       !            Prologue Checksum            ! 776
                       !-----------------------------------------!
         KD$BLN = 146 = Length of Key Descriptor


         RMS-11 Internals                                              Page 10





                 Bits defined in K$FLGS (byte)

                 +-------------------------------+
                 !   !   !   !XB$!   !XB$!XB$!XB$!
                 !   !   !   !INI!   !NUL!CHG!DUP!
                 +-------------------------------+

                 XB$DUP =   1 = Duplicate Key Values Allowed
                 XB$CHG =   2 = Key Value May Change on Update
                 XB$NUL =   4 = Null Key Character Enabled
                 XB$INI =  20 = Index has not been initialized

                 K$NLVB/K$NHVB  define  the  VBN of the next Key Descriptor
                     Block.  This is examined only if K$NBYT is 0.  If both
                     K$NLVB/K$NHVB  and  K$NBYT  are zero there are no more
                     Key Descriptor Blocks.
                 K$NBYT  defines the byte offset of the next Key Descriptor
                     Block  in  the  current  VBN (0 => next block in a new
                     VBN)
                 K$IAN/K$LAN/K$DAN  define  the  Index  &  Data  Level Area
                     Numbers (RMR 5-31, 5-41, 5-48)
                 K$LVL  defines  the  level  number of the Root Bucket (RMR
                     5-50)
                 K$IBKS/K$DBKS  define  the Index & Data Level Bucket Sizes
                     (RMR 5-33, 5-43)
                 K$LVBN/K$HVBN define the Root Bucket VBN (RMR 5-59).
                     Note  that  if  XB$INI is set in K$FLGS the four bytes
                     starting  at  K$LVBN contain K$DAN/K$IAN/K$LAN/0 (I do
                     not know why).
                 K$DTP  defines  the  Key Data Type (RMR 5-36). The various
                     types have the following values:-
                     XB$STG = 0
                     XB$IN2 = 1
                     XB$BN2 = 2
                     XB$IN4 = 3
                     XB$BN4 = 4
                     XB$PAC = 5
                 K$NSEG defines the number of Key Segments (RMR 5-52)
                 K$NULL  defines  the Null Key Character (RMR 5-53).  It is
                     only defined if XB$NUL is set in K$FLGS.
                 K$KYSZ defines the total size of the key (RMR 5-63).
                 K$KEY  defines  the  Key  of  Reference being defines (RMR
                     5-58).
                 K$MINL  defines  the  Minimum Record Length containing the
                     key (RMR 5-51).
                 K$IFIL/K$DFIL   define   the  Index  &  Data  Bucket  Fill
                     Quantities (RMR 5-34 & 5-44).
                 K$POS/K$SIZ  define the Key Segment Positions & Sizes (RMR
                     5-56 & 5-60)
                 K$KNM defines the Key Name (RMR 5-46).
                 K$LDVB/K$HDVB defines the Data Bucket VBN (RMR 5-38).


         RMS-11 Internals                                              Page 11





                 P$AVBN  holds  the VBN of the first Area Descriptor Block.
                     As  this immediately follows the Key Descriptor Blocks
                     of  which  there  are  at  most 52 (for 255 keys) this
                     value  must  be in the range 2-53 (and hence fits in a
                     byte).
                 P$AMAX defines the Number of Areas defined (RMR 5-75).
                 P$VERN defines the Prologue Version Number (RMR 5-78).

                 The  checksum at the end of the block is calculated as for
                 Relative Files.

                 Alternate  Key  Prologue Blocks contain up to five sets of
                 Key  Descriptor  Blocks  (as  in  Block  1  up to, but not
                 including,  P$AVBN) plus a checksum word calculated as for
                 block 1.  [5 * 146 + 2 = 1000.]

         RMS-11 Internals                                              Page 12





                 Key  Descriptor  Blocks  are  followed  by Area Descriptor
                 Blocks, each of which is formatted as follows:-

                              _____________________________                              On-Disk Area Descriptor (ARD)

         (Offsets defined in ARDOF$, Bit Values in XAB$BT)
                       !-----------------------------------------!
         A$FILL/A$FLG  !       Flags        !       Spare        !   0
                       !-----------------------------------------!
         A$AID /A$BKZ  !    Bucket Size     !    Area Number     !   2
                       !-----------------------------------------!
         A$VOL         !         Relative Volume Number          !   4
                       !-----------------------------------------!
         A$ALN /A$AOP  ! Allocation Options ! Alignment Options  !   6
                       !-----------------------------------------!
         A$AVL         !             First Available             !  10
                       !-----                               -----!
         A$AVL2        !             Returned Bucket             !  12
                       !-----------------------------------------!
         A$CVB         !              Current Start              !  14
                       !-----                               -----!
         A$CVB2        !                   VBN                   !  16
                       !-----------------------------------------!
         A$CNB         !            Number of Blocks             !  20
                       !-----                               -----!
         A$CNB2        !                in Extent                !  22
                       !-----------------------------------------!
         A$NUS         !            Number of Blocks             !  24
                       !-----                               -----!
         A$NUS2        !                  Used                   !  26
                       !-----------------------------------------!
         A$NVB         !                Next VBN                 !  30
                       !-----                               -----!
         A$NVB2        !               to be Used                !  32
                       !-----------------------------------------!
         A$NXT         !               Next Extent               !  34
                       !-----                               -----!
         A$NXT2        !                Start VBN                !  36
                       !-----------------------------------------!
         A$XBY         !            Number of Blocks             !  40
                       !-----                               -----!
         A$XBY2        !              in New Extent              !  42
                       !-----------------------------------------!
         A$DEQ         !        Default Extend Allocation        !  44
                       !-----------------------------------------!
                       !         Spare for Control Flags         !  46
                       !-----------------------------------------!
         A$LOC         !           Allocation Starting           !  50
                       !-----                               -----!
         A$LOC2        !                  Point                  !  52
                       !-----------------------------------------!
         A$RFI         !                 Related                 !  54
         A$RFI0        !-----                               -----!
         A$RFI1        !                  File                   !  56
                       !-----                               -----!
         A$RFI2        !                   ID                    !  60

         RMS-11 Internals                                              Page 13





                       !-----------------------------------------!
         A$FILL2       !             Spare (6 words)             !  62
                       .                                         .
                       .                                         .
                       !-----------------------------------------!
         A$CRC         !             Check Character             !  76
                       !-----------------------------------------!
         AD$BLN = 100 = Length of Area Descriptor

                 Bits Defined in A$ALN (byte)

                 +-------------------------------+
                 !   !   !   !   !XB$!XB$!XB$!XB$!
                 !   !   !   !   !RFI!VBN!LBN!CYL!
                 +-------------------------------+

                 XB$CYL =  1 = Cylinder Alignment (VAX only)
                 XB$LBN =  2 = Logical Block Alignment
                 XB$VBN =  4 = Virtual Block Alignment
                 XB$RFI = 10 = Allocate   close   to   related   file  (not
                               implemented)

                 Bits defined in A$AOP (byte)

                 +-------------------------------+
                 !   !   !   !   !   !   !XB$!XB$!
                 !   !   !   !   !   !   !CTG!HRD!
                 +-------------------------------+

                 XB$HRD =  1 = Alignment   is   absolute   &  fail  if  not
                               available
                 XB$CTG =  2 = Allocation is to be contiguous

                 A$FLG is currently not used.
                 A$AID is the Area Number (RMR 5-4).
                 A$BKZ is the Bucket Size in blocks (RMR 5-10).
                 A$VOL is the Relative Volume Number (not implemented).
                 A$ALN is the Alignment Options (RMR 5-5).
                 A$AOP is the Allocation Options (RMR 5-9).
                 A$AVL is the VBN of the first bucket in a chain of buckets
                     returned by RMS for reuse (not implemented).
                 A$CVB  defines  the  VBN of the first block of the current
                     extent.
                 A$CNB defines the number of blocks in the current extent.
                 A$NUS  defines  the number of blocks in the current extent
                     that have been used so far.
                 A$NVB  defines  the  VBN of the first block in the current
                     extent which has not yet been used.
                 A$NXT/A$XBY  define  the  start  VBN  and size of the next
                     extent to be used by the area (allocated by $EXTEND).
                 A$DEQ defines the default extend quantity (RMR 5-14).
                 A$LOC defines the LBN at which the extent starts.
                 A$RFI  defines  the file ID of the related file for XB$RFI
                     alignment (not implemented).
                 A$CRC  is  a dummy for the first seven Area Descriptors in
                     the  block,  and  in  the eighth contains the standard
                     checksum as defined for the Prologue Block 1.

         RMS-11 Internals                                              Page 14





                 ______________________________         e)      Indexed Files - Bucket Headers

                 As  discussed in RUG (5-2) every bucket in an Indexed File
                 after the Prologue contains a 14-byte Bucket Header at the
                 start of the first block in the Bucket, and a 1-byte Check
                 Byte as the last byte of the last block of the bucket.
                 The format of the Bucket Header is as follows:-

                                  _____________________                                  General Bucket Header

         (Offsets defined in BKTOF$, Bit Values in BKT$DF)
                       !-----------------------------------------!
         B$CHK /B$TAA  !    Area Number     !  Check Character   !   0
                       !-----------------------------------------!
         B$ADR         !     Low order word of bucket's VBN      !   2
                       !-----------------------------------------!
         B$NBY         !           Next Available Byte           !   4
                       !-----------------------------------------!
         B$NID /B$LID  !  Last ID in Range  !   Next Record ID   !   6
                       !-----------------------------------------!
         B$NBK         !              Start VBN of               !  10
                       !-----                               -----!
                       !               Next Bucket               !  12
                       !-----------------------------------------!
         B$LEV /B$BCB  !Bucket Control Bits !Bucket Level Number !  14
                       !-----------------------------------------!
         S$BHD = 16 = Size of Header Area
         B$REC = 16 = Offset of Start of Record Area

                 Bits defined in B$BCB(byte)

                 +-------------------------------+
                 !   !   !   !   !   !   !BC$!BC$!
                 !   !   !   !   !   !   !ROT!LBK!
                 +-------------------------------+

                 BC$LBK =     1 = Last Bucket in Index
                 BC$ROT =     2 = Root Bucket of Index

                 B$CHK  holds  the  one  byte  check character.  Whenever a
                     bucket  is  written  the  value  in  the check byte is
                     changed  and  copied into the last byte of the bucket.
                     Whenever  a  bucket is read the check byte is compared
                     to the copy for equality.  The idea of this is to trap
                     hardware failures during transfer.
                 B$TAA  holds  the  area  number of the area from which the
                     bucket was allocated.
                 B$ADR contains the low order 16 bits of the bucket's start
                     VBN  address.   It is written when the bucket is first
                     formatted and checked whenever the bucket is read into
                     memory.
                 B$NBY  defines  the  offset  relative  to the start of the
                     bucket of the first free byte.

         RMS-11 Internals                                              Page 15





                 B$NID  holds  the  ID  number  to be allocated to the next
                     record placed in the bucket.
                 B$LID holds the highest ID number that can be allocated.
                 B$NBK  defines  the  start  VBN of the next bucket at this
                     level of Index/Data.  If there is no next bucket it is
                     set to the start VBN of the current bucket.
                 B$LEV  holds  the  level  number  of the bucket within the
                     index of which it forms a part.  (0=Data Level).


         RMS-11 Internals                                              Page 16





                 ______________________________         f)      Indexed Files - Record Headers

                 Records  on  an  RMS Indexed File are chained together via
                 various  record  headers.   Consistent through them all is
                 the  idea  of  the Bucket Pointer & the Record Pointer.  A
                 Bucket  Pointer  is  a variable-length (2-4 bytes, see RUG
                 6-17)  field  containing  the  VBN  of  the  bucket  it is
                 pointing  to  (the size of the field being determined by a
                 2-bit  field  in  a  control  byte).   A Record Pointer is
                 simply  a  Bucket Pointer preceded by a one-byte Record ID
                 within the bucket.

                        ___________________                        Index Bucket Record

                       !--------------------!
         B$PS          !     IRCB     !  PS !   0
         B$IRCB        !              !     !
                       !--------------------!
         B$BPTR        !   Bucket Pointer   !   1
                       !     (n Bytes)      !
                       !--------------------!
                       !     Key Value      ! n+1
                       !    (m Bytes)       !
                       !--------------------!
         S$IDXR = 1 = Size of Index Record Overhead

                 Bits defined in B$PS/B$IRCB (byte)

                 +-------------------------------+
                 !   !   !   !IC$!IC$!IC$!  PS   !
                 !   !   !   !NUL!EMP!KCP!       !
                 +-------------------------------+

                 PS     = 0-3 = Bucket Pointer Size (0 = 2 bytes, etc.)
                 IC$KCP =  4  = Compressed   Key   Value   (not   currently
                                defined)
                 IC$EMP = 10  = Pointer to Empty Bucket
                 IC$NUL = 20  = Null Key Value (not currently used)

                 As  discussed  in RUG (5-6) the Index Record simply points
                 to  a  bucket in the next level of the Index (possibly the
                 data  level) and indicates the highest key defined in that
                 bucket.


         RMS-11 Internals                                              Page 17





                 __________________________________________________                 General Data Bucket Record/Record Reference Vector

                       !--------------------!
         B$PS          !     DRCB     !  PS !   0
         B$DRCB        !              !     !
                       !--------------------!
         B$ID          !     Record ID      !   1
                       !--------------------!
         B$RPTR        !   Record Pointer   !   2
                       !     (5 Bytes)      !
                       !--------------------!
         S$UDR  = 7 = Size of UDR Record Overhead
         B$RHDR = 7 = Length of Data Record Header

                 Bits defined in B$DRCB/B$PS (byte)

                 +-------------------------------+
                 !   !DC$!DC$!DC$!DC$!DC$!  PS   !
                 !   !NCP!KDL!NPS!RRV!DEL!       !
                 +-------------------------------+

                 PS     =   2 = Record Pointer Size (5 bytes)
                 DC$DEL =   4 = Record has been deleted
                 DC$RRV =  10 = This is a Record Reference Vector
                 DC$NPS =  20 = No  pointer  size  field present (qualifies
                                PS)
                 DC$KDL =  40 = Pointer  to  record  for this key no longer
                                applies.    $UPDATE changed the key but the
                                record still exists.  (ID is set to 0.)
                 DC$NCP = 100 = Do not compress this deleted record.

                 As  discussed  in  RUG  (5-12)  when RMS moves a record it
                 leaves a seven-byte RRV in its original position, and then
                 updates  that  to  reflect  any  further moves.  The exact
                 method  adopted  by  RMS is reflected in the format above.
                 When  a  data  record is first created, the record pointer
                 field  points  to  itself.   When it is moved the RRV left
                 behind  is  a  copy  of the record header, but has the bit
                 DC$RRV set, and the record pointer field now points to the
                 actual  record  header.    In  addition the record pointer
                 field in the actual header points back to the RRV (to make
                 it easy to update it).  Note that although record pointers
                 are   theoretically  variable-length,  currently  in  this
                 context  they are always 5 bytes long.  Note also that the
                 RFA returned by a operation will always point to the RRV.

                 When  RMS-11  deletes  a record it does various odd things
                 (as  described  in  RUG  5-10,  5-16, 6-9 & 6-18) with the
                 effect  that  sometimes the RRV is compressed to two bytes
                 (B$DRCB/B$PS  &  B$ID)  with  the  bits DC$DEL, DC$RRV and
                 DC$NPS  set  in  B$DRCB.    In  other  cases however (when
                 duplicates  are  allowed  in the Primary Index) the entire
                 record header remains with the bits DC$DEL & DC$RRV set in
                 B$DRCB.    These 'deleted' RRVs are never removed from the
                 file.

         RMS-11 Internals                                              Page 18





                 As  discussed  in  RUG  (5-6) there are two types of 'data
                 record'  (i.e.  lowest-level index) for Secondary Indexes,
                 depending  on  whether  the index allows duplicate keys or
                 not.

                    _______________________________________________                    Secondary Index Data Record (no duplicate keys)

                       !--------------------!
         B$PS          !     DRCB     !  PS !   0
         B$DRCB        !              !     !
                       !--------------------!
         B$ID          !         ID         !   1
                       !--------------------!
         B$SIZ         !       Size of      !   2
                       !        SIDR        !
                       !--------------------!
         B$KEY         !     Key Value      !   4
                       !     (m bytes)      !
                       !--------------------!
                       !    SIDR Record     !   4+m
                       !      Pointer       !
                       !     (n Bytes)      !
                       !--------------------!
         S$SIDR = 4 = Size of SIDR Array Overhead

                    ____________________________________________                    Secondary Index Data Record (duplicate keys)

                       !--------------------!
         B$PS          !     DRCB     !  PS !   0
         B$DRCB        !              !     !
                       !--------------------!
         B$ID          !         ID         !   1
                       !--------------------!
                       !  Duplicate Count   !   2
                       !     (4 bytes)      !
                       !--------------------!
         (B$SIZ)       !       Size of      !   6
                       !        SIDR        !
                       !--------------------!
         (B$KEY)       !     Key Value      !   10
                       !     (m bytes)      !
                       !--------------------!
                       !    SIDR Record     !   10+m
                       !     Pointer #1     !
                       !     (n1 Bytes)     !
                       !--------------------!
                       !    SIDR Record     !   10+m+n1
                       !     Pointer #2     !
                       !     (n2 Bytes)     !
                       !--------------------!
                       :                    :
                       :                    :
                       !--------------------!
                       !    SIDR Record     !
                       !     Pointer #K     !
                       !     (nK Bytes)     !
                       !--------------------!

         RMS-11 Internals                                              Page 19






                 Bits defined in B$PS/B$DRCB

                 +-------------------------------+
                 !   !   !   !DC$!   !   !   PS  !
                 !   !   !   !NPS!   !   !       !
                 +-------------------------------+

                 PS     =  1 = Size of duplicate count field (4 bytes)
                 DC$NPS = 20 = No duplicate count field (if set)

                 Each  SIDR  Record  Pointer consists of a one byte DRCB/PS
                 followed  by a standard Record Pointer (Record ID + Bucket
                 Pointer).    The PS defines the size of the Bucket Pointer
                 and the DRCB may have the following bits set:-
                 DC$KDL = 40 = Pointers  has been deleted due to key change
                               during  an  update operation.  (ID is set to
                               zero.)
                 DC$DEL =  4 = Associated record has been deleted.

                 When  a  record is deleted, the effect on the SIDR depends
                 on  whether  or not duplicates are allowed.  If duplicates
                 are not allowed then the SIDR entry is simply deleted.  If
                 duplicates are allowed then the entry in the SIDR array is
                 merely  flagged  as  deleted.   Note that according to RUG
                 (6-9)  RMS  never  checks  the array to see if all records
                 have  been  deleted,  so  it  will  remain  as a permanent
                 overhead in the file.


         RMS-11 Internals                                              Page 20





                                     __________                                     CHAPTER II

                            ____________________________                            RMS-11 In-Core Table Layouts

                 ___________________         a)      User-Visible Tables

                                _______________________                                File Access Block (FAB)

         (Offsets defined in FABOF$, bit values in FAB$BT)
                       !-----------------------------------------!
         O$BID /O$BLN  !  Block Length(120) !  FAB Block ID(3)   !   0
                       !-----------------------------------------!
         O$CTX         !            User Context Area            !   2
                       !-----------------------------------------!
         O$IFI         !             Pointer to IFAB             !   4
         O$ISID        !           (Internal Stream ID)          !
                       !-----------------------------------------!
         O$STS         !          Primary Status Field           !   6
                       !-----------------------------------------!
         O$STV         !         Secondary Status Field          !  10
                       !-----------------------------------------!
         O$ALQ         !               Allocation                !  12
         O$ALQ0        !-----                               -----!
         O$ALQ1        !                Quantity                 !  14
                       !-----------------------------------------!
         O$DEQ         !   Default Extend Allocation Quantity    !  16
                       !-----------------------------------------!
         O$FAC /O$SHR  !  File Sharing Ctl  !  File Access Ctl   !  20
                       !-----------------------------------------!
         O$FOP         !              File Options               !  22
                       !-----------------------------------------!
         O$RTV /O$ORG  ! File Organisation  ! Retrieval Ptr Cnt  !  24
                       !-----------------------------------------!
         O$RAT /O$RFM  !   Record Format    ! Record Attributes  !  26
                       !-----------------------------------------!
         O$XAB         !          Address of XAB Chain           !  30
                       !-----------------------------------------!
         O$BPA         !       Private Buffer Pool Address       !  32
                       !-----------------------------------------!
         O$BPS         !       Size of Private Buffer Pool       !  34
                       !-----------------------------------------!
         O$MRS         !           Maximum Record Size           !  36
                       !-----------------------------------------!
         O$MRN         !                 Maximum                 !  40
         O$MRN0        !                                         !
                       !-----                               -----!
         O$MRN1        !              Record Number              !  42
                       !-----------------------------------------!
         O$JNL         !      Pointer to Log Control Block       !  44
                       !-----------------------------------------!
         O$NAM         !          Address of Name Block          !  46
                       !-----------------------------------------!
         O$FNA         !       Address of File Name String       !  50

         RMS-11 Internals                                              Page 21





                       !-----------------------------------------!
         O$DNA         !     Address of Default Name String      !  52
                       !-----------------------------------------!
         O$FNS /O$DNS  !  Size of Default   ! Size of File Name  !  54
                       !-----------------------------------------!
         O$BLS         !      Block Size (Magtape, 18-8192)      !  56
                       !-----------------------------------------!
         O$FSZ /O$BKS  !    Bucket Size     !  VFC Header Size   !  60
                       !-----------------------------------------!
         O$DEV /O$LCH  !  Logical Channel   !    Device Chars    !  62
                       !-----------------------------------------!
                       !                  Spare                  !  64
                       !-----                               -----!
                       !                                         !  66
                       !-----------------------------------------!
         O$FT0         !                                         !  70
                       !-----                               -----!
         O$FT1         !                   FAB                   !  72
                       !-----                               -----!
         O$FT2         !                Temporary                !  74
                       !-----                               -----!
         O$FT3         !                Workspace                !  76
                       !-----                               -----!
         O$FT4         !                                         ! 100
                       !-----------------------------------------!
         O$FBD0        !        BDB Mapping Data Window 0        ! 102
                       !-----------------------------------------!
         O$FBD1        !        BDB Mapping Data Window 1        ! 104
                       !-----------------------------------------!
         O$FBDB        !   Address of BDB after I/O Operation    ! 106
                       !-----------------------------------------!
         O$FOVL        !        Procedure Overlay Vector         ! 110
                       !-----------------------------------------!
         O$FPAR        !   Pointer to Caller's Parameter List    ! 112
                       !-----------------------------------------!
         O$FIOS        !         Primary Internal Status         ! 114
                       !-----------------------------------------!
         O$FIO2        !        Secondary Internal Status        ! 116
                       !-----------------------------------------!
         FB$BLN=120=Length of FAB

                 Bits defined in O$FAC (byte)

                 +-------------------------------+
                 !   !   !FB$!FB$!FB$!FB$!FB$!FB$!
                 !   !   !BIO!TRN!UPD!DEL!GET!PUT!
                 +-------------------------------+

                 FB$PUT =   1 = Put Access
                 FB$GET =   2 = Get Access (Default)
                 FB$DEL =   4 = Delete Access
                 FB$UPD =  10 = Update Access
                 FB$TRN =  20 = Truncate Access (Sequential Files)
                 FB$BIO =  40 = Block I/O Access
                 FB$REA =  42 = Block I/O Read Access
                 FB$WRT =  41 = Block I/O Write Access

         RMS-11 Internals                                              Page 22






                 Bits defined in O$SHR (byte)

                 +-------------------------------+
                 !   !FB$!FB$!FB$!FB$!FB$!FB$!FB$!
                 !   !NIL!BIO!TRN!UPD!DEL!GET!PUT!
                 +-------------------------------+

                 As for O$FAC plus
                 FB$NIL = 100 = No Shared Access at all
                 FB$WRI =  15 = Allow Write Access

                 Values defined in O$ORG (byte)

                 FB$SEQ =   0 = Sequential (Default)
                 FB$REL =  20 = Relative
                 FB$IDX =  40 = Indexed
                 FB$HSH =  60 = ?
                 FB$DBM = 100 = ?
                 FB$FMX = 100 = Value of Maximum File Organisation

                 Bits defined in O$RAT (byte)

                 +-------------------------------+
                 !   !   !   !   !FB$!FB$!FB$!FB$!
                 !   !   !   !   !BLK!PRN!CR !FTN!
                 +-------------------------------+

                 FB$FTN =   1 = FORTRAN Control Character
                 FB$CR  =   2 = Carriage Control
                 FB$PRN =   4 = COBOL Control Character
                 FB$BLK =  10 = Record does not span block boundaries

                 Bits defined in O$FOP (word)

         +---------------------------------------------------------------+
         !   !   !FB$!FB$!FB$!FB$!FB$!FB$!FB$!FB$!FB$!FB$!FB$!FB$!FB$!FB$!
         !   !   !DFW!FID!MKD!TMP!NEF!SUP!CTG!ACK!JNL!DLK!POS!WAT!RWC!RWO!
         +---------------------------------------------------------------+

                 FB$RWO =     1 = Rewind on Open
                 FB$RWC =     2 = Rewind on Close
                 FB$WAT =     4 = Wait for File
                 FB$POS =    10 = Poistion after most-recently closed file
                 FB$DLK =    20 = Don't Lock if not Properly Closed
                 FB$JNL =    40 = Explicit Logging
                 FB$ACK =   100 = Verify File Attributes
                 FB$CTG =   200 = Contiguous File Extents
                 FB$SUP =   400 = Supercede Existing File
                 FB$NEF =  1000 = Do not position magtape to end-of-file
                 FB$TMP =  2000 = Temporary File
                 FB$MKD =  4000 = Mark File for Delete
                 FB$TMD =  6000 = Mark Temporary File for Delete
                 FB$FID = 10000 = Open by 'File ID' if set
                 FB$DFW = 20000 = Deferred Write

         RMS-11 Internals                                              Page 23






                 Values defined in O$RFM (byte)

                 FB$UDF =     0 = Undefined format (Block I/O)
                 FB$FIX =     1 = Fixed Length
                 FB$VAR =     2 = Variable Length (Default)
                 FB$VFC =     3 = Variable with Fixed Control
                 FB$STM =     4 = ASCII Stream Format

                 Bits defined in O$DEV (byte)

                 +-------------------------------+
                 !   !   !FB$!FB$!FB$!FB$!FB$!FB$!
                 !   !   !SQD!SDI!MDI!TRM!CCL!REC!
                 +-------------------------------+

                 FB$REC =  1 = Record Oriented Device
                 FB$CCL =  2 = Carriage Control Device
                 FB$TRM =  4 = Keyboard/Printer Terminal
                 FB$MDI = 10 = Device is Multi-Directory Structured
                 FB$SDI = 20 = Single Directory Only
                 FB$SQD = 40 = Sequential Device

                 For a detailed discussion of the fields/bits/values in the
                 FAB see RMR (Chapter 3).

         RMS-11 Internals                                              Page 24





                           _________________________                           Record Access Block (RAB)

         _________________________________________________         (Offsets defined in RABOF$, bit values in RAB$BT)
                       ___________________________________________                       !-----------------------------------------!
         _____________________________________________________________         O$BID /O$BLN  !Block Length(120/240)!  RAB Block ID(1)  !   0
                       ___________________________________________                       !-----------------------------------------!
         _____________________________________________________________         O$CTX         !              Context Area               !   2
                       ___________________________________________                       !-----------------------------------------!
         _____________________________________________________________         O$ISI         !       Stream ID (Pointer to IRAB)       !   4
                       ___________________________________________                       !-----------------------------------------!
         _____________________________________________________________         O$STS         !             Primary Status              !   6
                       ___________________________________________                       !-----------------------------------------!
         _____________________________________________________________         O$STV         !            Secondary Status             !  10
                       ___________________________________________                       !-----------------------------------------!
         _____________________________________________________________         O$RFA         !                Record's                 !  12
                       ___________________________________________                       !-----                               -----!
                       _______________________________________________                       !                  File                   !  14
                       ___________________________________________                       !-----                               -----!
                       _______________________________________________                       !                 Address                 !  16
                       ___________________________________________                       !-----------------------------------------!
         _____________________________________________________________         O$RAC /O$KSZ  !      Key Size      ! Record Access Ctl  !  20
                       ___________________________________________                       !-----------------------------------------!
         _____________________________________________________________         O$ROP         !             Record Options              !  22
                       ___________________________________________                       !-----------------------------------------!
         _____________________________________________________________         O$USZ         !           Size of User Buffer           !  24
                       ___________________________________________                       !-----------------------------------------!
         _____________________________________________________________         O$UBF         !         Address of User Buffer          !  26
                       ___________________________________________                       !-----------------------------------------!
         _____________________________________________________________         O$RSZ         !          Size of Record Buffer          !  30
                       ___________________________________________                       !-----------------------------------------!
         _____________________________________________________________         O$RBF         !        Address of Record Buffer         !  32
                       ___________________________________________                       !-----------------------------------------!
         _____________________________________________________________         O$KBF         !          Address of Key Buffer          !  34
                       ___________________________________________                       !-----------------------------------------!
         _____________________________________________________________         O$KRF /O$MBF  ! Multi-Buffer Count !  Key of Reference  !  36
                       ___________________________________________                       !-----------------------------------------!
         O$MBC /O$RT1A ! Temporary Workspace! Multi-Block Count  !  40
                       !-----------------------------------------!
         O$RHB         !      Address of VFC Header Buffer       !  42
                       !-----------------------------------------!
         O$FAB         !             Address of FAB              !  44
                       !-----------------------------------------!
         O$BKT(0)      !                 Bucket                  !  46
         O$DCT(0)      !                                         !
                       !-----                               -----!
         O$BKT1        !                 Number                  !  50
         O$DCT1        !                                         !
                       !-----------------------------------------!
                       !                Reserved                 !  52
                       !-----------------------------------------!
         O$RT0         !                   RAB                   !  54
           !           :                Temporary                :
           V           :                  Work                   :
         O$RT10        :                 Space                   :
                       :               (11. words)               :

         RMS-11 Internals                                              Page 25





                       !-----------------------------------------!
         O$RBD0        !        BDB Mapping Data Window 0        ! 102
                       !-----------------------------------------!
         O$RBD1        !        BDB Mapping Data Window 1        ! 104
                       !-----------------------------------------!
         O$RBD2        !        @BDB after I/O Operation         ! 106
                       !-----------------------------------------!
         O$ROVL        !        Procedure Overlay Vector         ! 110
                       !-----------------------------------------!
         O$RPAR        !   Pointer to Caller's Parameter List    ! 112
                       !-----------------------------------------!
         O$RIOS        !         Internal Primary Status         ! 114
                       !-----------------------------------------!
         O$RIO2        !        Internal Secondary Status        ! 116
                       !-----------------------------------------!
         O$RASY        !              Asynchronous               ! 120
                       :                Work Area                :
                       :               (40. words)               :
                       !-----------------------------------------!
         RB$BLN = 120 = Length of Synchronous RAB
         RB$BLL = 240 = Length of Asynchronous RAB

                 Values defined in O$RAC (byte)

                 RB$SEQ = 0 = Sequential Access (Default)
                 RB$KEY = 1 = Key Access
                 RB$RFA = 2 = RFA Access

                 Bits defined in O$ROP (word)

         +---------------------------------------------------------------+
         !   !RB$!RB$!RB$!RB$!RB$!RB$!RB$!RB$!RB$!RB$!RB$!RB$!RB$!RB$!RB$!
         !   !RCN!UIF!FDL!KGT!KGE!WBH!RAH!ASY!LOC!ULK!LOA!HSH!WAT!MAS!EOF!
         +---------------------------------------------------------------+

                 RB$EOF =     1 = Position to End-of-File
                 RB$MAS =     2 = Mass-Insert Mode
                 RB$WAT =     4 = Wait if Record Unavailable
                 RB$RLK =     4 = Read Lock Records (TPS)
                 RB$HSH =    10 = Use Hash Code in Bucket Field
                 RB$LOA =    20 = Follow Page Fill Percentages
                 RB$ULK =    40 = Manual Unlocking Procedures
                 RB$LOK =    40 = Record Lock Control Bit (TPS)
                 RB$LOC =   100 = Use Locate Mode on $GET
                 RB$ASY =   200 = Asynchronous I/O
                 RB$RAH =   400 = Read Ahead
                 RB$WBH =  1000 = Write Behind
                 RB$KGE =  2000 = Key Greater Than, or Equal
                 RB$KGT =  4000 = Key Greater Than
                 RB$FDL = 10000 = Fast Record Deletion
                 RB$UIF = 20000 = Update Record if it Exists
                 RB$RCN = 40000 = Relative File 'Put' Option


         RMS-11 Internals                                              Page 26





                 Bits defined in O$RT0 (byte used for Bucket Split control)

                 +-------------------------------+
                 !RB$!RB$!RB$!RB$!RB$!RB$!RB$!RB$!
                 !X2A!X1A!NW1!BK3!BK1!ORG!NK3!NKC!
                 +-------------------------------+

                 RB$NKC =   1 = No Key Change Required
                 RB$NK3 =   2 = No Key Chage for BKT-RT3/4
                 RB$ORG =   4 = Original Bucket gets High Key from R$NKAD
                 RB$BK1 =  10 = Last Bucket (O$RT1/2=VBN) gets old hi-key
                 RB$BK3 =  20 = Middle Bucket (O$RT3/4=VBN)-R(New)=hi-key
                 RB$NW1 =  40 = R(New) with R(Lo)
                 RB$X1A = 100 = All New Index Records in First Bucket
                 RB$X2A = 200 = All New Index Records in Last Bucket

                 All  RAB  offsets/bits/values are described in full in RMR
                 (Chapter 4).


         RMS-11 Internals                                              Page 27





                                ______________________                                Format of Context Area

                 The 'context area' defines two sections.  The first is the
                 fields  common  to the FAB (from O$FBD0) and the RAB (from
                 O$RBD0).

         (Offsets defined in CTXOF$)
                       !-----------------------------------------!
         X$BDB0        !        BDB Mapping Data Window 0        ! -12
                       !-----------------------------------------!
         X$BDB1        !        BDB Mapping Data Window 1        ! -10
                       !-----------------------------------------!
         X$BDB         !   Pointer to BDB after I/O Operation    !  -6
                       !-----------------------------------------!
         X$OVLY        !        Procedure Overlay Vector         !  -4
                       !-----------------------------------------!
         X$PARM        !    Address of User's Parameter Block    !  -2
                       !-----------------------------------------!
         X$IOS         !         Primary Internal Status         !   0
                       !-----------------------------------------!
         X$IOS2        !        Secondary Internal Status        !   2
                       !-----------------------------------------!

                 The  second  section  is for the asynchronous RAB only and
                 follows on immediately from the first part therein.

                       !-----------------------------------------!
         X$STKS/       !   No. available    !No. of entries saved!   4
                       !-----------------------------------------!
         X$STKB        !                  Stack                  !   6
                       :                  Save                   :
                       :                  Area                   :
                       :               (11 words)                :
                       !-----------------------------------------!
         X$STKE        !                    !                    !
         X$ARGS/       !                    !  No. of arguments  !  34
         (P$CNT)       !                    !                    ! (0)
                       !-----------------------------------------!
         X$STRU        !            Structure Address            !  36
         (P$STRU)      !                                         ! (2)
                       !-----------------------------------------!
         X$ERR         !Address of User Error Completion Routine !  40
         (P$ERR)       !                                         ! (4)
                       !-----------------------------------------!
         X$SUC         ! Address of User Success Completion Rtn  !  42
         (P$SUC)       !                                         ! (6)
                       !-----------------------------------------!

         RMS-11 Internals                                              Page 28





                         _______________________________________                         Key Definition Extended Attribute Block

         (Offsets in XBKOF$, bit values in XAB$BT)
                       !-----------------------------------------!
         O$COD /O$BLN  ! Block Length (70)  !    XAB Code (1)    !   0
                       !-----------------------------------------!
         O$NXT         !      Pointer to next XAB in chain       !   2
                       !-----------------------------------------!
         O$REF /O$LVL  !  Root Index Level  !  Key of Reference  !   4
               /O$HAL  !  Hashing Algorithm !                    !
                       !-----------------------------------------!
         O$IFL         !     Index Bucket Fill Level (bytes)     !   6
                       !-----------------------------------------!
         O$DFL         !     Data Bucket Fill Level (bytes)      !  10
                       !-----------------------------------------!
         O$NUL /O$IAN  ! Index Area Number  !   Null Key Char    !  12
                       !-----------------------------------------!
         O$LAN /O$DAN  !  Data Area Number  !Low Level Index Area!  14
                       !-----------------------------------------!
         O$FLG /O$DTP  !   Key Data Type    !       Flags        !  16
                       !-----------------------------------------!
         O$KNM         !           Address of Key Name           !  20
                       !-----------------------------------------!
         O$POS         !                                         !  22
         O$POS0        !-----                               -----!
                       !                   Key                   !  24
           !           !-----                               -----!
           V           !                                         !  26
                       !-----                               -----!
         O$POS7        !                 Segment                 !  30
                       !-----                               -----!
                       !                                         !  32
                       !-----                               -----!
                       !                Positions                !  34
                       !-----                               -----!
                       !                                         !  36
                       !-----                               -----!
                       !                                         !  40
                       !-----------------------------------------!
         O$SIZ         !                   Key                   !  42
         O$SIZ0        !-----                               -----!
                       !                 Segment                 !  44
           !           !-----                               -----!
           V           !                  Sizes                  !  46
                       !-----                               -----!
         O$SIZ7        !                                         !  50
                       !-----------------------------------------!
         O$RVB         !         VBN of file containing          !  52
                       !-----                               -----!
                       !           Root of this Index            !  54
                       !-----------------------------------------!
         O$DVB         !         VBN of File containing          !  56
                       !-----                               -----!
                       !     1st Data Bucket for this Index      !  60

         RMS-11 Internals                                              Page 29





                       !-----------------------------------------!
         O$IBS /O$DBS  !  Data Bucket Size  ! Index Bucket Size  !  62
                       !-----------------------------------------!
         O$NSG /O$TKS  !   Total Key Size   !  No. Key Segments  !  64
                       !-----------------------------------------!
         O$MRL         !            Minimum Rec Size             !  66
                       !-----------------------------------------!
         XB$KYL = 70 = Length of Key XAB

                 Bits defined in O$FLG (byte)

                 +-------------------------------+
                 !   !   !   !XB$!   !XB$!XB$!XB$!
                 !   !   !   !INI!   !NUL!CHG!DUP!
                 +-------------------------------+

                 XB$DUP =  1 = Duplicate Keys Allowed
                 XB$CHG =  2 = Keys Allowed to Change
                 XB$NUL =  4 = Null Key Defined
                 XB$INI = 20 = Index Must be Initialized

                 Values defined in O$DTP (byte)

                 XB$STG =  0 = ASCII string
                 XB$IN2 =  1 = 2-byte signed integer
                 XB$BN2 =  2 = 2-byte unsigned integer
                 XB$IN4 =  3 = 4-byte signed integer
                 XB$BN4 =  4 = 4-byte unsigned integer
                 XB$PAC =  5 = packed decimal


         RMS-11 Internals                                              Page 30





                          ____________________________________                          Date & Time Extended Attribute Block

         (Offsets defined in XBDOF$)
                       !-----------------------------------------!
         O$COD /O$BLN  ! Block Length (36)  !    XAB Code (2)    !   0
                       !-----------------------------------------!
         O$NXT         !      Pointer to next XAB in chain       !   2
                       !-----------------------------------------!
         O$RVN         !         RMS-11 Revision Number          !   4
                       !-----------------------------------------!
         O$RDT         !                                         !   6
                       !-----                               -----!
                       !              Last Revision              !  10
                       !-----                               -----!
                       !                  Date                   !  12
                       !-----                               -----!
                       !                                         !  14
                       !-----------------------------------------!
         O$CDT         !                                         !  16
                       !-----                               -----!
                       !                Creation                 !  20
                       !-----                               -----!
                       !                  Date                   !  22
                       !-----                               -----!
                       !                                         !  24
                       !-----------------------------------------!
         O$EDT         !                                         !  26
                       !-----                               -----!
                       !               Expiration                !  30
                       !-----                               -----!
                       !                  Date                   !  32
                       !-----                               -----!
                       !                                         !  34
                       !-----------------------------------------!
         XB$DTL = 36 = Length of Date-Time XAB


         RMS-11 Internals                                              Page 31





                        ________________________________________                        File Protection Extended Attribute Block

         (Offsets defined in XBPOF$)
                       !-----------------------------------------!
         O$COD /O$BLN  ! Block length (12)  !    XAB Code (3)    !   0
                       !-----------------------------------------!
         O$NXT         !      Pointer to next XAB in Chain       !   2
                       !-----------------------------------------!
         O$PRG         !      Programmer Number in account       !   4
                       !-----------------------------------------!
         O$PRJ         !        Project Number in account        !   6
                       !-----------------------------------------!
         O$PRO         !             File Protection             !  10
                       !-----------------------------------------!
         XB$PRL = 12 = Length of Protection XAB


         RMS-11 Internals                                              Page 32





                        ________________________________________                        Area Allocation Extended Attribute Block

         (Offsets defined in XBAOF$, bit values in XAB$BT)
                       !-----------------------------------------!
         O$COD /O$BLN  ! Block Length (34)  !    XAB Code (4)    !   0
                       !-----------------------------------------!
         O$NXT         !      Address of next XAB in chain       !   2
                       !-----------------------------------------!
         O$AID /O$BKZ  !  Area Bucket Size  !      Area ID       !   4
                       !-----------------------------------------!
         O$VOL         !         Relative Volume Number          !   6
                       !-----------------------------------------!
         O$ALN /O$AOP  ! Allocation Options ! Alignment Options  !  10
                       !-----------------------------------------!
         O$ALQ         !            Area's Allocation            !  12
         O$ALQ0        !                                         !
                       !-----                               -----!
         O$ALQ1        !                Quantity                 !  14
                       !-----------------------------------------!
         O$DEQ         !Area's Default Extend Allocation Quantity!  16
                       !-----------------------------------------!
                       !                  Spare                  !  20
                       !-----------------------------------------!
         O$LOC         !        Allocation Starting Point        !  22
         O$LOC0        !                                         !
                       !-----                               -----!
         O$LOC1        !                for Area                 !  24
                       !-----------------------------------------!
         O$RFI         !                 Related                 !  26
         O$RFI0        !                                         !
                       !-----                               -----!
         O$RFI1        !                  File                   !  30
                       !-----                               -----!
         O$RFI2        !                   ID                    !  32
                       !-----------------------------------------!
         XB$LAL = 34 = Length of Allocation XAB

                 Bits defined in O$ALN (byte)

                 +-------------------------------+
                 !   !   !   !   !XB$!XB$!XB$!XB$!
                 !   !   !   !   !RFI!VBN!LBN!CYL!
                 +-------------------------------+

                 XB$CYL =  1 = Cylinder Alignment
                 XB$LBN =  2 = Logical Block Alignment
                 XB$VBN =  4 = Virtual Block Alignment
                 XB$RFI = 10 = Allocate Close to Related File ID


         RMS-11 Internals                                              Page 33





                 Bits defined in O$AOP (byte)

                 +-------------------------------+
                 !   !   !   !   !   !   !XB$!XB$!
                 !   !   !   !   !   !   !CTG!HRD!
                 +-------------------------------+

                 XB$HRD = 1 = Abort if Allocation Alignment Fails
                 XB$CTG = 2 = Perform Contiguous Allocation


         RMS-11 Internals                                              Page 34





                         ________________________________                         Summary Extended Attribute Block

         (Offsets defined in XBSOF$)
                       !-----------------------------------------!
         O$COD /O$BLN  ! Block Length (12)  !    XAB Code (5)    !   0
                       !-----------------------------------------!
         O$NXT         !      Address of Next XAB in Chain       !   2
                       !-----------------------------------------!
         O$NOK /O$NOA  !    No. of Areas    !    No. of Keys     !   4
                       !-----------------------------------------!
         O$NOR /       !       Spare        !No. of Record Descrs!   6
                       !-----------------------------------------!
         O$PVN         !             Prologue Number             !  10
                       !-----------------------------------------!
         XB$SML = 12 = Length of Summary XAB

                 All  XAB  offsets/bits values are described in full in RMR
                 (Chapter 5).

                 Note that the macro XAB$BT defines six more XAB type codes
                 for O$COD which appear to be currently unused:-

                 XB$ULB =  6 = User Label
                 XB$FCB =  7 = Statistics from File Manager
                 XB$HDR = 10 = Complete File Header
                 XB$USR = 11 = User Characteristics
                 XB$NAM = 12 = File Name in Header
                 XB$ACC = 13 = Access Control List


         RMS-11 Internals                                              Page 35





                                    ________________                                    Name Block (NAM)

         (Offsets defined in NAMOF$)
                       !-----------------------------------------!
         O$RLF         !         Address of Related FAB          !   0
                       !-----------------------------------------!
         O$RSA         !    Resultant Filename String Address    !   2
                       !-----------------------------------------!
         O$RSS /O$RSL  ! Actual Size of RFS ! Size of RFS Buffer !   4
                       !-----------------------------------------!
         O$DVI         !                 Actual                  !   6
                       !-----                               -----!
                       !                 Device                  !  10
                       !-----                               -----!
                       !                   ID                    !  12
                       !-----------------------------------------!
         O$FID         !                 Actual                  !  14
                       !-----                               -----!
                       !                  File                   !  16
                       !-----                               -----!
                       !                   ID                    !  20
                       !-----------------------------------------!
         O$DID         !                 Actual                  !  22
                       !-----                               -----!
                       !                Directory                !  24
                       !-----                               -----!
                       !                   ID                    !  26
                       !-----------------------------------------!
         O$FNB         !        Address of Filename Block        !  30
                       !-----------------------------------------!
         O$ESA         !   Address of Expanded Filename String   !  32
                       !-----------------------------------------!
         O$ESS /O$ESL  ! Actual Size of EFS ! Size of EFS Buffer !  34
                       !-----------------------------------------!
         O$WCC         !         Wildcard Context Buffer         !  36
                       !-----------------------------------------!
         NB$BLN = 40 = Length of NAM block

                 All NAM offsets are described in full in RMR (Chapter 6).


         RMS-11 Internals                                              Page 36





                                 _______________________                                 Log Control Block (LCB)

         (Offsets defined in LCBOF$)
                       !-----------------------------------------!
         O$BIR         !     Address of Before-Image Routine     !   0
                       !-----------------------------------------!
         O$CTX         !              Context Area               !   2
                       !-----------------------------------------!
         O$AIR         !     Address of After-Image Routine      !   4
                       !-----------------------------------------!
         O$BUF         !             Buffer Address              !   6
                       !-----------------------------------------!
         O$LSZ         !               Bucket Size               !  10
                       !-----------------------------------------!
         O$BLK         !              Start VBN of               !  12
         O$BLK0        !                                         !
                       !-----                               -----!
         O$BLK1        !                 Bucket                  !  14
                       !-----------------------------------------!
         LB$BLN = 16 = Length of LCB

                 The  LCB is listed as a 'User-Visible' table in the RMS-11
                 Design  &  Logic Manual and is presumably intended for use
                 in  some  form  of journalling that is to be bundled in to
                 RMS-11 in the future.  Apart for the macro defining it, it
                 appears currently to be unsupported.


         RMS-11 Internals                                              Page 37





                 _______________         b)      Internal Tables

                                    ________________                                    Transfer Vectors

         (Offsets defined in TRVOF$)
                       !-----------------------------------------!
         TV$OPE        !Address of Sequential File 'Open' Routine!   0
                       !-----                               -----!
                       ! Address of Relative File 'Open' Routine !   2
                       !-----                               -----!
                       ! Address of Indexed File 'Open' Routine  !   4
                       !-----                               -----!
                       !  Address of 'Dir' File 'Open' Routine   !   6
                       !-----------------------------------------!
         TV$CRE        !     Addresses of 'Create' Routines      !  10
                       !-----------------------------------------!
         TV$CLO        !      Addresses of 'Close' Routines      !  20
                       !-----------------------------------------!
         TV$CON        !     Addresses of 'Connect' Routines     !  30
                       !-----------------------------------------!
         TV$DIS        !   Addresses of 'Disconnect' Routines    !  40
                       !-----------------------------------------!
         TV$GET        !       Addresses of 'Get' Routines       !  50
                       !-----------------------------------------!
         TV$PUT        !       Addresses of 'Put' Routines       !  60
                       !-----------------------------------------!
         TV$UPD        !     Addresses of 'Update' Routines      !  70
                       !-----------------------------------------!
         TV$DEL        !     Addresses of 'Delete' Routines      ! 100
                       !-----------------------------------------!
         TV$FIN        !      Addresses of 'Find' Routines       ! 110
                       !-----------------------------------------!

                 Transfer Vectors reside in PSECT $$RMS1


         RMS-11 Internals                                              Page 38





                                 ______________________                                 Impure Area Definition

         (Offsets defined in IMAOF$, bit values in IMA$BT)
                       !-----------------------------------------!
         Y$BDBH        !             BDB Block Pool              !   0
                       !-----                               -----!
                       !                Listhead                 !   2
                       !-----------------------------------------!
         Y$IRAH        !             IRAB Block Pool             !   4
                       !-----                               -----!
                       !                Listhead                 !   6
                       !-----------------------------------------!
         Y$IFAH        !           IFAB/IDX Block Pool           !  10
                       !-----                               -----!
                       !                Listhead                 !  12
                       !-----------------------------------------!
         Y$KEYH        !          Key String Buffer Pool         !  14
                       !-----                               -----!
                       !                Listhead                 !  16
                       !-----------------------------------------!
         Y$BFLH        !               Buffer Pool               !  20
                       !-----                               -----!
                       !                Listhead                 !  22
                       !-----------------------------------------!
         Y$WIN0/Y$WIN1 !  Mapping Window 1  !  Mapping Window 0  !  24
                       !-----------------------------------------!
         Y$DREG        !          Dynamic Region Number          !  26
                       !-----------------------------------------!
         Y$DYLH        !           Dynamic Mapped Pool           !  30
                       !-----                               -----!
                       !                Listhead                 !  32
                       !-----------------------------------------!
         Y$FATL        !     Address of Fatal Error Routine      !  34
                       !-----------------------------------------!
         Y$ENSP        !          Unadjusted Entry "SP"          !  36
                       !-----------------------------------------!
         Y$CTXP        !   Context Pointer (to O$RIOS/O$FIOS)    !  40
                       !-----------------------------------------!
         Y$STKR        !            Stack Reset Value            !  42
                       !-----------------------------------------!
         Y$WKQH        !             Work Queue Head             !  44
                       !-----------------------------------------!
         Y$WKQT        !             Work Queue Tail             !  46
                       !-----------------------------------------!
         Y$SYSV        !              System Status              !  50
                       !-----------------------------------------!
         Y$IFAB        !            IFAB List Pointer            !  52
                       !-----------------------------------------!
         Y$RMSV        !           RMS Version Number            !  54
                       !-----------------------------------------!
         Y$RECN        !  Pointer to Record Number/RFA Routine   !  56
                       !-----------------------------------------!
         Y$GSA         !           GSA Routine Address           !  60

         RMS-11 Internals                                              Page 39





                       !-----------------------------------------!
         Y$AUTO        !                Auto-Load                !  62
                       !-----                               -----!
                       !                  Call                   !  64
                       !-----------------------------------------!
         Y$QIO         !                                         !
         Y$DIC         !             DIC & DPB size              !  66
                       !-----------------------------------------!
         Y$IOFC        !            I/O Function Code            !  70
                       !-----------------------------------------!
         Y$LCHN        !           Logical Unit Number           !  72
                       !-----------------------------------------!
         Y$EFPI        !             EFN & Priority              !  74
                       !-----------------------------------------!
         Y$IOST        !       Address of I/O Status Block       !  76
                       !-----------------------------------------!
         Y$AST         !         Address of AST Routine          ! 100
                       !-----------------------------------------!
         Y$PARM        !                                         ! 102
                       !-----                               -----!
                       !                    6                    ! 104
                       !-----                               -----!
                       !                  Words                  ! 106
                       !-----                               -----!
                       !                   of                    ! 110
                       !-----                               -----!
                       !               Parameters                ! 112
                       !-----                               -----!
                       !                                         ! 114
                       !-----------------------------------------!
                       !                                         ! 116
                       !-----                               -----!
                       !                                         ! 120
                       !-----                               -----!
                       !                                         ! 122
                       !-----                               -----!
                       !                                         ! 124
                       !-----------------------------------------!
         Y$TSTA        !     Address of Start Thread Routine     ! 126
                       !-----------------------------------------!
         Y$READ        !    Address of Read Function Routine     ! 130
                       !-----------------------------------------!
         Y$WRIT        !    Address of Write Function Routine    ! 132
                       !-----------------------------------------!
         Y$SPFN        !  Address of Special Functions Routine   ! 134
                       !-----------------------------------------!
         Y$FILE        !    Address of File Functions Routine    ! 136
                       !-----------------------------------------!
         Y$WAIT        !       Address of I/O Wait Routine       ! 140
                       !-----------------------------------------!
         Y$GETS        !     Address of Get Segment Routine      ! 142
                       !-----------------------------------------!


         RMS-11 Internals                                              Page 40





                 Bit Values defined in Y$SYSV (word)

         +---------------------------------------------------------------+
         !   !   !   !   !   !   !   !   !   !   !   !   !SY$!SY$!SY$!SY$!
         !   !   !   !   !   !   !   !   !   !   !   !   !PLC!RLK!INI!AST!
         +---------------------------------------------------------------+

                 SY$AST =  1 = At AST Level
                 SY$INI =  2 = Impure Area has been Initialized
                 SY$RLK =  4 = RSX  -  Explicit  Locking  in  the Operating
                               System
                 SY$PLC = 10 = ?

                 The Impure Area resides in PSECT $$RMS4


         RMS-11 Internals                                              Page 41





                              _____________________________                              Buffer Descriptor Block (BDB)

         (Offsets defined in BDBOF$, bit values defined in BDB$BT)
                       !-----------------------------------------!
         B$WK1         !            Work Area Address            !   0
                       !-----------------------------------------!
         B$NXT         !      Address of next BDB in chain       !   2
                       !-----------------------------------------!
         B$OWN         !         Address of owning IRAB          !   4
                       !-----------------------------------------!
         B$NUMB        !          Number of Bytes Used           !   6
                       !-----------------------------------------!
         B$WAIT        !         Pointer to Wait Thread          !  10
                       !-----------------------------------------!
         B$FLGS/B$USE  !     Use Count      !       Flags        !  12
                       !-----------------------------------------!
         B$LVBN        !            Low VBN of Block             !  14
                       !-----------------------------------------!
         B$HVBN        !            High VBN of Block            !  16
                       !-----------------------------------------!
         B$SIZE        !             Size of Buffer              !  20
                       !-----------------------------------------!
         B$ADDR        !            Address of Buffer            !  22
                       !-----------------------------------------!
         BD$BLN = 24 = Length of BDB

                 Bits defined in B$FLGS (byte)

                 +-------------------------------+
                 !BD$!BD$!BD$!BD$!BD$!BD$!BD$!BD$!
                 !ELK!WFO!PRM!DYM!LCK!IOP!DRT!VAL!
                 +-------------------------------+

                 BD$VAL =   1 = Buffer Contents Valid
                 BD$DRT =   2 = Buffer Contents Dirty (i.e. have changed)
                 BD$IOP =   4 = I/O in Progress for Buffer
                 BD$LCK =  10 = Buffer is Locked
                 BD$DYM =  20 = Dynamic Mapping Required for Buffer
                 BD$PRM =  40 = Buffer has Permanence Factor
                 BD$WFO = 100 = Streams waiting for this BDB
                 BD$ELK = 200 = Blocks Explicitly Locked

                 BDBs reside in PSECT $RMS11


         RMS-11 Internals                                              Page 42





                           ___________________________________                           Internal Record Access Block (IRAB)

         (Offsets defined in IRAOF$, bit values in IRA$BT)
                       !-----------------------------------------!
         C$BID /C$BKP1 !  Bookkeeping Bits  !    IRAB ID (11)    !   0
                       !-----------------------------------------!
         C$NIRB        !          Address of Next IRAB           !   2
                       !-----------------------------------------!
         R$IFAB        !         Address of Related IFAB         !   4
                       !-----------------------------------------!
         R$CBDB        !         Address of Current BDB          !   6
                       !-----------------------------------------!
         R$NBDB        !           Address of Next BDB           !  10
                       !-----------------------------------------!
         R$LNRP        !           Next Record Pointer           !  12
                       !-----                               -----!
         R$HNRP        !                   VBN                   !  14
                       !-----------------------------------------!
         R$INRP/R$KNRP !NRP Key of Reference!   NRP Record ID    !  16
         R$BNRP        !NRP - Seq File Org Byte Offset into Block!
                       !-----------------------------------------!
         R$LRP         !          Current Record Pointer         !  20
                       !-----                               -----!
         R$HRP         !                  VBN                    !  22
                       !-----------------------------------------!
         R$IRP /R$KRP  !RP Key of Reference !    RP Record ID    !  24
         R$BRP         ! RP - Seq/Rel Org Byte Offset into Block !
                       !-----------------------------------------!
         R$IRRV/R$BCNT !  Seq. Block Count  !       RRV ID       !  26
         R$MBC/        !                    ! Multi-Block Count  !
                       !-----------------------------------------!
         R$LRRV        !             RRV - Low Word              !  30
         R$CSIZ        !  Current Record(Seq) or Cell(Rel) Size  !
                       !-----------------------------------------!
         R$HRRV        !             RRV - High Word             !  32
                       !-----------------------------------------!
         R$NKAD        !     Address of Internal Key Buffer      !  34
                       !-----------------------------------------!
         R$SPOS        !     Entry Number in Dup/SIDR Array      !  36
                       !-----------------------------------------!
         IR$BLN = 40 = Size of IRAB


         RMS-11 Internals                                              Page 43





                 Bits defined in C$BKP1 (byte)

                 +-------------------------------+
                 !BK$!BK$!BK$!BK$!BK$!BK$!BK$!BK$!
                 !ASY!FND!BLK!SEQ!SSK!DUP!IOP!BUS!
                 +-------------------------------+

                 BK$BUS =   1 = Stream is Busy
                 BK$IOP =   2 = I/O Pending on Stream (Seq ORG only)
                 BK$DUP =   4 = Duplicate Records Seen
                 BK$SSK =  10 = Segmented Search Key
                 BK$EOF =  10 = File at EOF (Seq ORG only)
                 BK$SEQ =  20 = Last  operation was a Put Seq or, if BK$FND
                                is set, a Find Seq.  (Not true during Write
                                operation on Indexed File.)
                 BK$BLK =  40 = Connected for Block I/O.
                 BK$IDX = 100 = Index Update Error Occurred.
                 BK$FND = 100 = Last Operation was a Find.
                 BK$ASY = 200 = Asynchronous I/O Stream.

                 BDBs reside in PSECT $RMS13.


         RMS-11 Internals                                              Page 44





                        _________________________________                        Internal File Access Block (IFAB)

         (Offsets defined in IFAOF$, bit values in IFA$BT)
                       !-----------------------------------------!
         C$BID /C$BKP1 !  Bookkeeping Bits  !    IFAB ID (13)    !   0
                       !-----------------------------------------!
         C$NIRB        !      Address of Next IRAB in Chain      !   2
                       !-----------------------------------------!
         F$UBSZ/F$LCHN !  Logical Channel   !  User Buffer Size  !   4
                       !-----------------------------------------!
         F$DVCH/F$FACC !    File Access     !    Device Chars    !   6
                       !-----------------------------------------!
                       !                  Spare                  !  10
                       !-----                               -----!
                       !                  Spare                  !  12
                       !-----------------------------------------!
         F$BDBP        !          Address of BDB Chain           !  14
                       !-----------------------------------------!
         F$IFAB        !          Address of IFAB Chain          !  16
                       !-----------------------------------------!
         F$POOL        !            File Private Pool            !  20
                       !-----                               -----!
                       !                Listhead                 !  22
                       !-----------------------------------------!
         F$LMRN        !    Maximum Record Number - Low Word     !  24
         F$IDXP        !      Ptr to Index Descriptor Chain      !
         F$BLSZ        !          Block Size (Tape Only)         !
                       !-----------------------------------------!
         F$HMRN        !    Maximum Record Number - High Word    !  26
         F$KBSZ        !             Key Buffer Size             !
                       !-----------------------------------------!
         F$AVBN/F$AMAX ! Max Area Number +1 !   Start Area VBN   !  30
         F$DVBN        !  First Data Bucket VBN (Relative File)  !
                       !-----------------------------------------!
         F$FORG/F$RATT ! Record Attributes  !    File Format     !  32
                       !-----------------------------------------!
         F$RSIZ        !               Record Size               !  34
                       !-----------------------------------------!
         F$HVBN        !       High Block VBN - High Word        !  36
                       !-----------------------------------------!
         F$LVBN        !        High Block VBN - Low Word        !  40
                       !-----------------------------------------!
         F$HEOF        !    End-of-File Block VBN - High Word    !  42
                       !-----------------------------------------!
         F$LEOF        !    End-of-File Block VBN - Low Word     !  44
                       !-----------------------------------------!
         F$FFBY        !             First Free Byte             !  46
                       !-----------------------------------------!
         F$BKSZ/F$HDSZ !  VFC Header Size   !Largest Bucket Size !  50
                       !-----------------------------------------!
         F$MRS         !           Maximum Record Size           !  52
                       !-----------------------------------------!
         F$DEQ         !   Default Extend Allocation Quantity    !  54

         RMS-11 Internals                                              Page 45





                       !-----------------------------------------!
         F$RTDE        !    Run Time Default Extend Quantity     !  56
                       !-----------------------------------------!
         IF$BLN = 60 = Length of IFAB

                 Bits defined in C$BKP1 (byte)

                 +-------------------------------+
                 !BK$!BK$!BK$!BK$!BK$!BK$!BK$!BK$!
                 !ANI!ACC!PAR!RWC!EOF!PRV!IOP!BUS!
                 +-------------------------------+

                 BK$BUS =   1 = Stream Busy
                 BK$IOP =   2 = I/O Pending on Stream (Seq File Only)
                 BK$PRV =   4 = Private I/O Buffer Pool for File
                 BK$EOF =  10 = File Positioned at EOF
                 BK$RWC =  20 = Rewind on Close
                 BK$PAR =  40 = ?
                 BK$DFW =  40 = Deferred Write
                 BK$ACC = 100 = File is Accessed (Cleared on Close)
                 BK$ANI = 200 = ANSI D Variable Record

                 Bits defined in F$DVCH

                 Same as O$DEV in FAB

                 Bits defined in F$FORG

                 Same as O$RFM + O$ORG in FAB

                 Bits defined in F$FACC

                 Same as O$FAC in FAB plus
                 FB$NIL = 100 = As in O$SHR in FAB
                 FB$SHR = 200 = Shared  Update.   Set when O$SHR in the FAB
                                is set to FB$PUT!FB$UPD!FB$DEL.

                 IFABs reside in PSECT $RMS15.


         RMS-11 Internals                                              Page 46





                           _____________________________                           Internal Key Descriptor (IDX)

         (Offsets defined in IDXOF$, bit values in IDX$BT.)
                       !-----------------------------------------!
         I$IBKS/I$DBKS !  Data Bucket Size  ! Index Bucket Size  !   0
                       !-----------------------------------------!
         I$NXT         !      Address of next IDX in chain       !   2
                       !-----------------------------------------!
         I$LVBN        !         VBN of Root - Low Word          !   4
         I$UDAR/I$IDAR !   Index Data Area  !   User Data Area   !
                       !-----------------------------------------!
         I$HVBN        !         VBN of Root - High Word         !   6
         I$LDAR/       !                    !  Lowest Level Area !
                       !-----------------------------------------!
         I$FLGS/I$DTP  !   Key Data Type    !       Flags        !  10
                       !-----------------------------------------!
         I$NSEG/I$NULL ! Null Key Character !  No. Key Segments  !  12
                       !-----------------------------------------!
         I$KYSZ/I$KEY  !  Key of Reference  !   Total Key Size   !  14
                       !-----------------------------------------!
         I$MINL        !    Minimum length record holding key    !  16
                       !-----------------------------------------!
         I$IFIL        !   Index Bucket Fill Quantity (bytes)    !  20
                       !-----------------------------------------!
         I$DFIL        !    Data Bucket Fill Quantity (bytes)    !  22
                       !-----------------------------------------!
         I$POS         !                                         !  24
         I$POS0        !-----                               -----!
                       !                   Key                   !  26
           !           !-----                               -----!
           V           !                                         !  30
                       !-----                               -----!
         I$POS7        !                 Segment                 !  32
                       !-----                               -----!
                       !                                         !  34
                       !-----                               -----!
                       !                Positions                !  36
                       !-----                               -----!
                       !                                         !  40
                       !-----                               -----!
                       !                                         !  42
                       !-----------------------------------------!
         I$SIZ         !                                         !  44
         I$SIZ0        !-----                               -----!
                       !                   Key                   !  46
           !           !-----                               -----!
           V           !                 Segment                 !  50
                       !-----                               -----!
         I$SIZ7        !                  Sizes                  !  52
                       !-----------------------------------------!
                       !                  Spare                  !  54
                       !-----                               -----!
                       !                  Spare                  !  56
                       !-----------------------------------------!
         ID$BLN = 60 = Size of IDX

         RMS-11 Internals                                              Page 47






                 Bits defined in I$FLGS (byte)

                 Same as O$FLG in Key-XAB.

                 IDXs are defined in PSECT $RMS15.




         RMS-11 Internals                                              Page 48





                 Most  of  the offsets/values used by RMS-11 are defined in
                 one of the macros illustrated above.  A few however reside
                 in the macro $LOCALS which defines the following:-
                 ;
                 ; Attribute Codes for Reading/Writing Attributes.
                 ;
                 HA.BLS=13          ; Magtape - Block Size
                 HA.UI=1            ; Owner's UIC
                 HA.FP=2            ; File Protection
                 HA.CHU=3           ; User's Characteristics Byte
                 HA.UAT=4           ; User's Record Attributes
                 HA.NAM=5           ; Filename (9 RAD50 chars)
                 HA.TYP=6           ; File type (3 RAD50 chars)
                 HA.VER=7           ; File version (1 word binary)
                 HA.NAW=10.         ; Number of attribute words
                 ;
                 ; The following symbols relate to explicit allocation.
                 ;
                 HA.EXT=14.         ; Extend attribute code
                 EX.ALL=20          ; Enable extend
                 AL.VBN=1           ; 1=VBN Allocation, 0=LBN Allocation
                 AL.APX=2           ; 1=Approximate Allocation
                                    ; 0=Fail if not exact
                 AL.LBN=4           ; Return LBN data on extent
                 AL.CYL=10          ;
                 ;
                 ; Define offsets within work area for $CREATE/$OPEN.
                 ;
                 S$PTRS=8.          ; 4 pointers = 8 bytes
                 S$BDB=0            ; Offset of pointer to BDB
                 S$NAM=2            ; Offset of pointer to NAM
                 S$FNB=4            ; Offset of pointer to File Name Blk
                 S$ATR=6            ; Offset of pointer to Attribute List
                 S.$SDC=3*4         ;
                 S$ESS=126.         ; Size of Expanded String Area

                 FA.ENB=100000      ; Enable Access
                 FA.WCK=20000       ; Write Check
                 FA.SEQ=40000       ; Seq Proc for Disk
                 FA.LCK=400         ; Disallow Sharing
                 FA.XLK=4000        ; Enable Explicit Block Locking.
                 FA.DLK=1000        ; Deaccess Lock Enable
                 FA.RWD=4000        ; Mag Tape Rewind Control
                 FA.POS=10000       ; Magtape Create File Position Control
                 FA.FLL=2000        ; Force Lock List
                 FA.NEF=40000       ; Magtape don't position to EOF


         RMS-11 Internals                                              Page 49





                 It  is  also occasionally desirable to know the value of a
                 particular  RMS-11  offset  or bit value without having to
                 check  through  all  the tables above.  The following is a
                 list of all the 'local' RMS-11 symbols and their values.

             AD$BLN= 000100  AL.APX= 000002  AL.CYL= 000010  AL.LBN= 000004
             AL.VBN= 000001  A$AID = 000002  A$ALN = 000006  A$AOP = 000000
             A$AVL = 000010  A$AVL2= 000012  A$BKZ = 000003  A$CNB = 000020
             A$CNB2= 000022  A$CRC = 000076  A$CVB = 000014  A$CVB2= 000016
             A$DEQ = 000044  A$FILL= 000062  A$FLG = 000001  A$LOC = 000050
             A$LOC2= 000052  A$NUS = 000024  A$NUS2= 000026  A$NVB = 000030
             A$NVB2= 000032  A$NXT = 000034  A$NXT2= 000036  A$RFI = 000054
             A$RFI0= 000054  A$RFI1= 000056  A$RFI2= 000060  A$VOL = 000004
             A$XBY = 000040  A$XBY2= 000042  BC$LBK= 000001  BC$ROT= 000002
             BD$BLN= 000024  BD$DRT= 000002  BD$DYM= 000020  BD$ELK= 000200
             BD$IOP= 000004  BD$LCK= 000010  BD$PRM= 000040  BD$VAL= 000001
             BD$WFO= 000100  BK$ACC= 000100  BK$ANI= 000200  BK$ASY= 000200
             BK$BLK= 000040  BK$BUS= 000001  BK$DFW= 000040  BK$DUP= 000004
             BK$EOF= 000010  BK$FND= 000100  BK$IDX= 000100  BK$IOP= 000002
             BK$PAR= 000040  BK$PRV= 000004  BK$RWC= 000020  BK$SEQ= 000020
             BK$SSK= 000010  B$ADDR= 000022  B$ADR = 000002  B$BCB = 000015
             B$BPTR= 000001  B$CHK = 000000  B$DRCB= 000000  B$FLGS= 000012
             B$HVBN= 000016  B$ID  = 000001  B$IRCB= 000000  B$KEY = 000004
             B$LEV = 000014  B$LID = 000007  B$LVBN= 000014  B$NBK = 000010
             B$NBY = 000004  B$NID = 000006  B$NUMB= 000006  B$NXT = 000002
             B$OWN = 000004  B$PS  = 000000  B$REC = 000016  B$RHDR= 000007
             B$RPTR= 000002  B$SIZ = 000002  B$SIZE= 000020  B$TAA = 000001
             B$USE = 000013  B$WAIT= 000010  B$WK1 = 000000  C$BID = 000000
             C$BKP1= 000001  C$NIRB= 000002  DC$DEL= 000004  DC$KDL= 000040
             DC$NCP= 000100  DC$NPS= 000020  DC$REC= 000010  DC$RRV= 000010
             ER$ABO= 177760  ER$ACC= 177740  ER$ACT= 177720  ER$AID= 177700
             ER$ALN= 177660  ER$ALQ= 177640  ER$ANI= 177620  ER$AOP= 177600
             ER$AOR= 177570  ER$AST= 177560  ER$ATR= 177540  ER$ATW= 177520
             ER$BKS= 177500  ER$BKZ= 177460  ER$BLN= 177440  ER$BOF= 177430
             ER$BPA= 177420  ER$BPS= 177400  ER$BUG= 177360  ER$CCR= 177340
             ER$CHG= 177320  ER$CHK= 177300  ER$CLS= 177260  ER$COD= 177240
             ER$CRE= 177220  ER$CUR= 177200  ER$DAC= 177160  ER$DAN= 177140
             ER$DEL= 177120  ER$DEV= 177100  ER$DFW= 177070  ER$DIR= 177060
             ER$DME= 177040  ER$DNF= 177020  ER$DNR= 177000  ER$DPE= 176770
             ER$DTP= 176760  ER$DUP= 176740  ER$ENT= 176720  ER$ENV= 176700
             ER$EOF= 176660  ER$ESS= 176640  ER$EXP= 176630  ER$EXT= 176620
             ER$FAB= 176600  ER$FAC= 176560  ER$FEX= 176540  ER$FID= 177530
             ER$FLG= 176520  ER$FLK= 176500  ER$FND= 176460  ER$FNF= 176440
             ER$FNM= 176420  ER$FOP= 176400  ER$FSS= 176370  ER$FUL= 176360
             ER$IAN= 176340  ER$IDX= 176320  ER$IFI= 176300  ER$IMX= 176260
             ER$INI= 176240  ER$IOP= 176220  ER$IRC= 176200  ER$ISI= 176160
             ER$ITI= 176150  ER$KBF= 176140  ER$KEY= 176120  ER$KRF= 176100
             ER$KSZ= 176060  ER$LAN= 176040  ER$LBL= 176020  ER$LBY= 176000
             ER$LCH= 175760  ER$LEX= 175750  ER$LIU= 175744  ER$LOC= 175740
             ER$MAP= 175720  ER$MKD= 175700  ER$MRN= 175660  ER$MRS= 175640
             ER$NAM= 175620  ER$NEF= 175600  ER$NID= 175560  ER$NLA= 175550
             ER$NPK= 175540  ER$NRG= 175534  ER$NTT= 175530  ER$OPN= 175520
             ER$ORD= 175500  ER$ORG= 175460  ER$PLG= 175440  ER$POS= 175420
             ER$PRM= 175400  ER$PRV= 175360  ER$RAB= 175340  ER$RAC= 175320

         RMS-11 Internals                                              Page 50





             ER$RAT= 175300  ER$RBF= 175260  ER$RER= 175240  ER$REX= 175220
             ER$RFA= 175200  ER$RFM= 175160  ER$RLK= 175140  ER$RMV= 175120
             ER$RNF= 175100  ER$RNL= 175060  ER$ROP= 175040  ER$RPL= 175020
             ER$RRV= 175000  ER$RSA= 174760  ER$RSZ= 174740  ER$RTB= 174720
             ER$RVU= 174710  ER$SEQ= 174700  ER$SHR= 174660  ER$SIZ= 174640
             ER$STK= 174620  ER$SYS= 174600  ER$TRE= 174560  ER$TYP= 174540
             ER$UBF= 174520  ER$USZ= 174500  ER$VER= 174460  ER$VOL= 174440
             ER$WCD= 174430  ER$WER= 174420  ER$WLK= 174410  ER$WPL= 174400
             ER$XAB= 174360  ER$XTR= 174340  EX.ALL= 000020  FA.DLK= 001000
             FA.ENB= 100000  FA.FLL= 002000  FA.LCK= 000400  FA.NEF= 040000
             FA.POS= 010000  FA.RWD= 004000  FA.SEQ= 040000  FA.WCK= 020000
             FA.XLK= 004000  FB$ACK= 000100  FB$BID= 000003  FB$BIO= 000040
             FB$BLK= 000010  FB$BLN= 000120  FB$CCL= 000002  FB$CR = 000002
             FB$CTG= 000200  FB$DBM= 000100  FB$DEL= 000004  FB$DFW= 020000
             FB$DLK= 000020  FB$FID= 010000  FB$FIX= 000001  FB$FMX= 000100
             FB$FTN= 000001  FB$GET= 000002  FB$HSH= 000060  FB$IDX= 000040
             FB$JNL= 000040  FB$MDI= 000010  FB$MKD= 004000  FB$NEF= 001000
             FB$NIL= 000100  FB$POS= 000010  FB$PRN= 000004  FB$PUT= 000001
             FB$REA= 000042  FB$REC= 000001  FB$REL= 000020  FB$RWC= 000002
             FB$RWO= 000001  FB$SDI= 000020  FB$SEQ= 000000  FB$SHR= 000200
             FB$SQD= 000040  FB$STM= 000004  FB$SUP= 000400  FB$TMD= 006000
             FB$TMP= 002000  FB$TRM= 000004  FB$TRN= 000020  FB$UDF= 000000
             FB$UPD= 000010  FB$VAR= 000002  FB$VFC= 000003  FB$WAT= 000004
             FB$WRI= 000015  FB$WRT= 000041  F$AMAX= 000031  F$AVBN= 000030
             F$BDBP= 000014  F$BKSZ= 000050  F$BLSZ= 000024  F$DEQ = 000054
             F$DVBN= 000030  F$DVCH= 000006  F$FACC= 000007  F$FFBY= 000046
             F$FORG= 000032  F$HDSZ= 000051  F$HEOF= 000042  F$HMRN= 000026
             F$HVBN= 000036  F$IDXP= 000024  F$IFAB= 000016  F$KBSZ= 000026
             F$LCHN= 000005  F$LEOF= 000044  F$LMRN= 000024  F$LVBN= 000040
             F$MRS = 000052  F$POOL= 000020  F$RATT= 000033  F$RSIZ= 000034
             F$RTDE= 000056  F$UBSZ= 000004  HA.BLS= 000013  HA.CHU= 000003
             HA.EXT= 000016  HA.FP = 000002  HA.NAM= 000005  HA.NAW= 000012
             HA.TYP= 000006  HA.UAT= 000004  HA.UI = 000001  HA.VER= 000007
             IC$EMP= 000010  IC$KCP= 000004  IC$NUL= 000020  ID$BLN= 000060
             IF$BID= 000013  IF$BLN= 000060  IR$BID= 000011  IR$BLN= 000040
             I$DBKS= 000001  I$DFIL= 000022  I$DTP = 000011  I$FLGS= 000010
             I$HVBN= 000006  I$IBKS= 000000  I$IDAR= 000005  I$IFIL= 000020
             I$KEY = 000015  I$KYSZ= 000014  I$LDAR= 000006  I$LVBN= 000004
             I$MINL= 000016  I$NSEG= 000012  I$NULL= 000013  I$NXT = 000002
             I$POS = 000024  I$POS0= 000024  I$POS1= 000026  I$POS2= 000030
             I$POS3= 000032  I$POS4= 000034  I$POS5= 000036  I$POS6= 000040
             I$POS7= 000042  I$SIZ = 000044  I$SIZ0= 000044  I$SIZ1= 000045
             I$SIZ2= 000046  I$SIZ3= 000047  I$SIZ4= 000050  I$SIZ5= 000051
             I$SIZ6= 000052  I$SIZ7= 000053  I$UDAR= 000004  KD$BLN= 000146
             K$DAN = 000010  K$DBKS= 000013  K$DFIL= 000032  K$DTP = 000021
             K$FLGS= 000020  K$HDVB= 000126  K$HVBN= 000016  K$IAN = 000006
             K$IBKS= 000012  K$IFIL= 000030  K$KEY = 000025  K$KNM = 000064
             K$KYSZ= 000024  K$LAN = 000007  K$LDVB= 000124  K$LVBN= 000014
             K$LVL = 000011  K$MINL= 000026  K$NBYT= 000004  K$NHVB= 000002
             K$NLVB= 000000  K$NSEG= 000022  K$NULL= 000023  K$POS = 000034
             K$POS0= 000034  K$POS1= 000036  K$POS2= 000040  K$POS3= 000042
             K$POS4= 000044  K$POS5= 000046  K$POS6= 000050  K$POS7= 000052
             K$SIZ = 000054  K$SIZ0= 000054  K$SIZ1= 000055  K$SIZ2= 000056
             K$SIZ3= 000057  K$SIZ4= 000060  K$SIZ5= 000061  K$SIZ6= 000062

         RMS-11 Internals                                              Page 51





             K$SIZ7= 000063  LB$BLN= 000016  NB$BLN= 000040  O$AID = 000004
             O$AIR = 000004  O$ALN = 000010  O$ALQ = 000012  O$ALQ0= 000012
             O$ALQ1= 000014  O$AOP = 000011  O$BID = 000000  O$BIR = 000000
             O$BKS = 000061  O$BKT = 000046  O$BKT0= 000046  O$BKT1= 000050
             O$BKZ = 000005  O$BLK = 000012  O$BLK0= 000012  O$BLK1= 000014
             O$BLN = 000001  O$BLS = 000056  O$BPA = 000032  O$BPS = 000034
             O$BUF = 000006  O$CDT = 000016  O$COD = 000000  O$CTX = 000002
             O$DAN = 000015  O$DBS = 000063  O$DCT = 000046  O$DCT0= 000046
             O$DCT1= 000050  O$DEQ = 000016  O$DEV = 000062  O$DFL = 000010
             O$DID = 000022  O$DNA = 000052  O$DNS = 000055  O$DTP = 000017
             O$DVB = 000056  O$DVI = 000006  O$EDT = 000026  O$ESA = 000032
             O$ESL = 000035  O$ESS = 000034  O$FAB = 000044  O$FAC = 000020
             O$FBDB= 000106  O$FBD0= 000102  O$FBD1= 000104  O$FID = 000014
             O$FIOS= 000114  O$FIO2= 000116  O$FLG = 000016  O$FNA = 000050
             O$FNB = 000030  O$FNS = 000054  O$FOP = 000022  O$FOVL= 000110
             O$FPAR= 000112  O$FSZ = 000060  O$FT0 = 000070  O$FT1 = 000072
             O$FT2 = 000074  O$FT3 = 000076  O$FT4 = 000100  O$HAL = 000005
             O$IAN = 000013  O$IBS = 000062  O$IFI = 000004  O$IFL = 000006
             O$ISI = 000004  O$ISID= 000004  O$JNL = 000044  O$KBF = 000034
             O$KNM = 000020  O$KRF = 000036  O$KSZ = 000021  O$LAN = 000014
             O$LCH = 000063  O$LOC = 000022  O$LOC0= 000022  O$LOC1= 000024
             O$LSZ = 000010  O$LVL = 000005  O$MBC = 000040  O$MBF = 000037
             O$MRL = 000066  O$MRN = 000040  O$MRN0= 000040  O$MRN1= 000042
             O$MRS = 000036  O$NAM = 000046  O$NOA = 000005  O$NOK = 000004
             O$NOR = 000006  O$NSG = 000064  O$NUL = 000012  O$NXT = 000002
             O$ORG = 000025  O$POS = 000022  O$POS0= 000022  O$POS1= 000024
             O$POS2= 000026  O$POS3= 000030  O$POS4= 000032  O$POS5= 000034
             O$POS6= 000036  O$POS7= 000040  O$PRG = 000004  O$PRJ = 000006
             O$PRO = 000010  O$PVN = 000010  O$RAC = 000020  O$RASY= 000120
             O$RAT = 000026  O$RBDB= 000106  O$RBD0= 000102  O$RBD1= 000104
             O$RBF = 000032  O$RDT = 000006  O$REF = 000004  O$RFA = 000012
             O$RFI = 000026  O$RFI0= 000026  O$RFI1= 000030  O$RFI2= 000032
             O$RFM = 000027  O$RHB = 000042  O$RIOS= 000114  O$RIO2= 000116
             O$RLF = 000000  O$ROP = 000022  O$ROVL= 000110  O$RPAR= 000112
             O$RSA = 000002  O$RSL = 000005  O$RSS = 000004  O$RSZ = 000030
             O$RTV = 000024  O$RT0 = 000054  O$RT1 = 000056  O$RT1A= 000041
             O$RT10= 000100  O$RT2 = 000060  O$RT3 = 000062  O$RT4 = 000064
             O$RT5 = 000066  O$RT6 = 000070  O$RT7 = 000072  O$RT8 = 000074
             O$RT9 = 000076  O$RVB = 000052  O$RVN = 000004  O$SHR = 000021
             O$SIZ = 000042  O$SIZ0= 000042  O$SIZ1= 000043  O$SIZ2= 000044
             O$SIZ3= 000045  O$SIZ4= 000046  O$SIZ5= 000047  O$SIZ6= 000050
             O$SIZ7= 000051  O$STS = 000006  O$STV = 000010  O$TKS = 000065
             O$UBF = 000026  O$USZ = 000024  O$VOL = 000006  O$WCC = 000036
             O$XAB = 000030  PR$NEX= 000001  P$AMAX= 000147  P$AVBN= 000146
             P$CNT = 000000  P$DBKS= 000013  P$DVBN= 000150  P$DVB2= 000152
             P$ERR = 000004  P$FLGS= 000020  P$HEOF= 000162  P$HMRN= 000156
             P$LEOF= 000160  P$LMRN= 000154  P$STRU= 000002  P$SUC = 000006
             P$VERN= 000164  RB$ASY= 000200  RB$BID= 000001  RB$BK1= 000010
             RB$BK3= 000020  RB$BLL= 000240  RB$BLN= 000120  RB$EOF= 000001
             RB$FDL= 010000  RB$HSH= 000010  RB$KEY= 000001  RB$KGE= 002000
             RB$KGT= 004000  RB$LOA= 000020  RB$LOC= 000100  RB$LOK= 000040
             RB$MAS= 000002  RB$NKC= 000001  RB$NK3= 000002  RB$NW1= 000040
             RB$ORG= 000004  RB$RAH= 000400  RB$RCN= 040000  RB$RFA= 000002
             RB$RLK= 000004  RB$SEQ= 000000  RB$UIF= 020000  RB$ULK= 000040

         RMS-11 Internals                                              Page 52





             RB$WAT= 000004  RB$WBH= 001000  RB$X1A= 000100  RB$X2A= 000200
             R$BCNT= 000027  R$BNRP= 000016  R$BRP = 000024  R$CBDB= 000006
             R$CSIZ= 000030  R$HNRP= 000014  R$HRP = 000022  R$HRRV= 000032
             R$IFAB= 000004  R$INRP= 000016  R$IRP = 000024  R$IRRV= 000026
             R$KNRP= 000017  R$KRP = 000025  R$LNRP= 000012  R$LRP = 000020
             R$LRRV= 000030  R$MBC = 000026  R$NBDB= 000010  R$NKAD= 000034
             R$SPOS= 000036  R$$SFM= 000000  SU$DUP= 000002  SU$IDX= 000003
             SU$RLK= 000024  SU$RRV= 000004  SU$SUC= 000001  SY$AST= 000001
             SY$INI= 000002  SY$PLC= 000010  SY$RLK= 000004  S$ATR = 000006
             S$BDB = 000000  S$BHD = 000016  S$ESS = 000176  S$FNB = 000004
             S$IDXR= 000001  S$NAM = 000002  S$PTRS= 000010  S$SIDR= 000004
             S$UDR = 000007  S.$SDC= 000014  TV$CLO= 000020  TV$CON= 000030
             TV$CRE= 000010  TV$DEL= 000100  TV$DIS= 000040  TV$FIN= 000110
             TV$GET= 000050  TV$OPE= 000000  TV$PUT= 000060  TV$UPD= 000070
             XB$ACC= 000013  XB$ALL= 000004  XB$BN2= 000002  XB$BN4= 000004
             XB$CHG= 000002  XB$CTG= 000002  XB$CYL= 000001  XB$DAT= 000002
             XB$DTL= 000036  XB$DUP= 000001  XB$FCB= 000007  XB$HDR= 000010
             XB$HRD= 000001  XB$INI= 000020  XB$IN2= 000001  XB$IN4= 000003
             XB$KEY= 000001  XB$KYL= 000070  XB$LAL= 000034  XB$LBN= 000002
             XB$NAM= 000012  XB$NUL= 000004  XB$PAC= 000005  XB$PRL= 000012
             XB$PRO= 000003  XB$RFI= 000010  XB$SML= 000012  XB$STG= 000000
             XB$SUM= 000005  XB$ULB= 000006  XB$USR= 000011  XB$VBN= 000004
             X$ARGS= 000034  X$BDB = 177772  X$BDB0= 177766  X$BDB1= 177770
             X$ERR = 000040  X$IOS = 000000  X$IOS2= 000002  X$OVLY= 177774
             X$PARM= 177776  X$STKB= 000006  X$STKE= 000034  X$STKS= 000004
             X$STRU= 000036  X$SUC = 000042  Y$AST = 000100  Y$AUTO= 000062
             Y$BDBH= 000000  Y$BFLH= 000020  Y$CTXP= 000040  Y$DIC = 000066
             Y$DREG= 000026  Y$DYLH= 000030  Y$EFPI= 000074  Y$ENSP= 000036
             Y$FATL= 000034  Y$FILE= 000136  Y$GETS= 000142  Y$GSA = 000060
             Y$IFAB= 000052  Y$IFAH= 000010  Y$IOFC= 000070  Y$IOST= 000076
             Y$IRAH= 000004  Y$KEYH= 000014  Y$LCHN= 000072  Y$PARM= 000102
             Y$QIO = 000066  Y$READ= 000130  Y$RECN= 000056  Y$RMSV= 000054
             Y$SPFN= 000134  Y$STKR= 000042  Y$SYSV= 000050  Y$TSTA= 000126
             Y$WAIT= 000140  Y$WIN0= 000024  Y$WIN1= 000025  Y$WKQH= 000044
             Y$WKQT= 000046  Y$WRIT= 000132


         RMS-11 Internals                                              Page 53





                 RMS-11  uses  a  similar  method to COBOL to determine the
                 length of various areas - i.e. it defines values in R0IMPA
                 in  PSECTs  that  bracket  the  required  PSECT  and  thus
                 determine  the  start  address  &  length.  In this manner
                 RMS-11 uses the following PSECTs:-

                 $$RMSP  - Dummy
                 $$RMS1  - Transfer Vectors
                 $$RMS2  - Dummy
                 $$RMS3  - Buffer Pool
                 $$RMS4  - Impure Area
                 $RMS10  - Dummy
                 $RMS11  - BDBs
                 $RMS12  - Dummy
                 $RMS13  - IRABs
                 $RMS14  - Dummy
                 $RMS15  - IFABs/Index Descriptors
                 $RMS16  - Dummy
                 $RMS17  - Indexed File Key Buffers
                 $RMS18  - Dummy

                 In addition most RMS-11 modules reside in a PSECT with the
                 same name as the module.


         RMS-11 Internals                                              Page 54





                                    ___________                                    CHAPTER III

                                   _____________                                   RMS-11 MACROS

                 As anyone who has used RMS-11 from MACRO-11 knows to their
                 cost  the  whole of the MACRO-11/RMS-11 Interface consists
                 of  a  large number of macros, whose use increases program
                 assembly  time considerably.  Examination of the structure
                 of  these  macros  reveals the reason readily.  The RMS-11
                 designers took a very good idea (that of allowing the user
                 to  examine/change  any field without knowing where or how
                 large  it  was)  but apparently ignored the fact that this
                 would  require  a heavy system overhead (of heavily nested
                 macros)  without  really  providing an equivalently useful
                 facility  (it  is slightly pointless to allow the user not
                 to know how large a field is, as he will have to know that
                 to  do  anything meaningful with it).  This 'independence'
                 is  arrived  at by a whole series of nested macros setting
                 up and examining various offset/type values.

                 In  addition  the  macros  contain  a large amount of code
                 which  appears  once  to have been used for test purposes.
                 For  the  unsuspecting  user  who  does  not know of their
                 existence (as they are not documented) this merely results
                 in another overhead during assembly.  However the facility
                 they  provide  is  potentially  very  useful  and  will be
                 discussed at greater length later.

                 For  convenience the macros will be split out into several
                 sections in an attempt to illustrate their purpose.

                 _______         a)      General

                 DEF$SZ - is  invoked  as  an 'offset definition macro' and
                          simply calculates the size of the relevant table
                 DFIN$G - is  invoked  as  a  'value  definition macro' and
                          declares  the  given symbol as global and sets it
                          equal to the given value
                 DFIN$L - as  for  DFIN$G,  but  the symbol is not declared
                          global
                 DPSECT - simply generates a '.PSECT'
                 RMS$G  - is  invoked  as  an 'offset definition macro' and
                          declares  the  given  symbol  as  global and then
                          invokes RMS$L
                 RMS$L  - is invoked as an 'offset definition macro' (or by
                          RMS$G) and equivalences the symbol to the current
                          value  of  ...TPC,  updates  ...TPC  by the given
                          size,  and  invokes $EMSTG to output a string for
                          debugging purposes.
                 STRU$B - defines  the  start  of a structure for debugging
                          purposes.
                 STRU$E - defines  the  end  of  a  structure for debugging
                          purposes.
                 $EMSTG - stores a string for debugging purposes.
                 ..EMIT - merely  inserts  its argument in the source file,
                          turning  .LIST MEB on and off if the symbol LST$$
                          is defined.

         RMS-11 Internals                                              Page 55





                 _______________________         b)      Field Definition Macros

                 Each  field  in any RMS-11 table is defined by two values,
                 its  offset  from  the  start of the table and its length.
                 The  offset  is determined by the offset definition macros
                 (see  later)  and  the  length  is  set up in the variable
                 ...LEN by a set of macros of the form

                         $yyy$

                 where  yyy  is  the  name of the field in question.  (Note
                 that  the  macros also set up the symbol ...ERR which just
                 indicates  that  the mnemonic was valid.)  The macros that
                 fall into this category are listed below.

                 Firstly  the ones whose corresponding fields are discussed
                 in the relevant section of RMR:-

                 $AID$   $AIR$   $ALN$   $ALQ$   $AOP$   $BID$   $BIR$
                 $BKS$   $BKT$   $BKZ$   $BLK$   $BLN$   $BLS$   $BPA$
                 $BPS$   $BUF$   $CDT$   $COD$   $CTX$   $DAN$   $DBS$
                 $DCT$   $DEQ$   $DEV$   $DFL$   $DID$   $DNA$   $DNS$
                 $DTP$   $DVB$   $DVI$   $EDT$   $ESA$   $ESL$   $ESS$
                 $FAB$   $FAC$   $FBDB$  $FID$   $FIOS$  $FLG$   $FNA$
                 $FNB$   $FNS$   $FOP$   $FOVL$  $FPAR$  $FSZ$   $FT0$
                 $FT1$   $FT2$   $FT3$   $FT4$   $HAL$   $IAN$   $IBS$
                 $IFI$   $IFL$   $ISI$   $JNL$   $KBF$   $KNM$   $KRF$
                 $KSZ$   $LAN$   $LCH$   $LOC$   $LSZ$   $LVL$   $MBC$
                 $MBF$   $MRL$   $MRN$   $MRS$   $NAM$   $NOA$   $NOK$
                 $NOR$   $NSG$   $NUL$   $NXT$   $ORG$   $POS$   $POS0$
                 $POS1$  $POS2$  $POS3$  $POS4$  $POS5$  $POS6$  $POS7$
                 $PRG$   $PRJ$   $PRO$   $PVN$   $RAC$   $RAT$   $RBDB$
                 $RBF$   $RDT$   $REF$   $RFA$   $RFI$   $RFM$   $RHB$
                 $RIOS$  $RLF$   $ROP$   $ROVL$  $RPAR$  $RSA$   $RSL$
                 $RSS$   $RSZ$   $RTV$   $RT0$   $RT1A$  $RT1$   $RT10$
                 $RT2$   $RT3$   $RT4$   $RT5$   $RT6$   $RT7$   $RT8$
                 $RT9$   $RVB$   $RVN$   $SHR$   $SIZ$   $SIZ0$  $SIZ1$
                 $SIZ2$  $SIZ3$  $SIZ4$  $SIZ5$  $SIZ6$  $SIZ7$  $STS$
                 $STV$   $TKS$   $UBF$   $USZ$   $VOL$   $WCC$   $XAB$

                 See  Appendix  D  for  a  description of each of these
                 fields.

         RMS-11 Internals                                              Page 56





                 ______________ ____________         c)      Field Initialization Macros

                 The  initialization  method  adopted by RMS-11 is slightly
                 unusual.    Each  table  has  associated  with it a set of
                 definition macros:-

                 xxx$B   - Invokes  xxx$BT to define any bit values locally
                           (with  DFIN$L)  &  xxxDF$  to define offsets and
                           allocate  space  for the table.  It then invokes
                           $SEQCK  to check that the macro is valid in this
                           position.    If  so it sets up symbols to define
                           what  sort  of  table is being initialized (e.g.
                           ...TBL=1  and  ...FAB=1),  and a symbol for each
                           field  in  the table defining the default values
                           (e.g. $FOP=0).
                 xxx$BT  - Define  any  bit  values used in the table using
                           the macro passed it as a parameter.
                 xxxDF$  - Invokes  xxxOF$  to  define offsets in block xxx
                           locally   (with  RMS$L),  checks  the  block  is
                           word-aligned and if so reserves space for it via
                           ..EMIT, setting ...TAB to the start address.
                 xxxOF$  - Defines  offsets  in  block  xxx using the macro
                           passed it as a parameter and uses STRU$B, $EMSTG
                           &  STRU$E  optionally  to  set  up  a  debugging
                           harness.
                 xxx$E   - Invokes  $SEQCK  to  check the macro is valid in
                           this position, and if so invokes FIELD$ for each
                           field  in the table in order.  Resets symbols to
                           indicate  table  is  complete  (e.g.  ...TBL=0 &
                           ...FAB=0).

                 Also  for  each field there is a separate macro x$yyy (x=F
                 for  FAB,  R  for  RAB  etc. & yyy = Field Mnemonic) which
                 resets  the relevant equivalenced symbols to the specified
                 value.    Most of these macros each invoke the macro UFLD$
                 specifying  the structure the given field is valid for and
                 the options specified.  Macros corresponding to doubleword
                 fields  (e.g.  F$ALQ)  invoke  $WRDS  instead,  and macros
                 corresponding to 8-value fields (e.g. X$POS) invoke $STRIP
                 instead).

                 The macros used in this section are:-

                 FAB:    FABDF$  FABOF$  FAB$B   FAB$BT  FAB$E
                         F$ALQ   F$BKS   F$BLS   F$BPA   F$BPS   F$BSZ
                         F$CTX   F$DEQ   F$DNA   F$DNS   F$FAC   F$FNA
                         F$FNS   F$FOP   F$FSZ   F$JFN   F$JNL   F$LCH
                         F$MRN   F$MRS   F$NAM   F$ORG   F$RAT   F$RFM
                         F$RTV   F$SHR   F$XAB
                 RAB:    RABDF$  RABOF$  RAB$B   RAB$BT  RAB$E
                         R$BKT   R$CTX   R$FAB   R$KBF   R$KRF   R$KSZ
                         R$LSN   R$MBC   R$MBF   R$RAC   R$RBF   R$RHB
                         R$ROP   R$RSZ   R$UBF   R$USZ

         RMS-11 Internals                                              Page 57





                 XAB:    XABDF$  XABOF$  XAB$B   XAB$BT  XAB$E   XBAOF$
                         XBDOF$  XBKOF$  XBPOF$  XBSOF$
                         X$AID   X$ALN   X$ALQ   X$AOP   X$BKZ   X$DAN
                         X$DEQ   X$DFL   X$DTP   X$FLG   X$HAL   X$IAN
                         X$IFL   X$KNM   X$LAN   X$LOC   X$NUL   X$NXT
                         X$POS   X$PRG   X$PRJ   X$PRO   X$REF   X$SIZ
                         X$VOL
                 NAM:    NAMDF$  NAMOF$  NAM$B   NAM$E
                         N$ESA   N$ESS   N$RLF   N$RSA   N$RSS
                 LCB:    LCBDF$  LCBOF$  LCB$B   LCB$E
                         L$AIR   L$BIR   L$CTX

                 In  general, apart from the xxxDF$ & xxx$BT macros and, of
                 course,  all the LCB macros, these macros are described in
                 RMR  and have entries in the index.  For some reason a few
                 have  been  omitted  from the index, even though they have
                 entries  in  the  manual and a couple of others are not in
                 the manual at all.  These are:-

                 FABOF$  - 1-4
                 F$BPA   - 3-11
                 F$BSZ   - "Field Unused by RMS-11"
                 F$JFN   - "JFN Field is Not Supported by RMS-11"
                 F$JNL   - Defines pointer to LCB
                 NAMOF$  - 1-4
                 N$RLF   - Initializes RLF field
                 N$RSA   - Initializes RSA field
                 N$RSS   - Initializes RSS field
                 RABOF$  - 1-4
                 R$LSN   - "R$LSN Not Supported by RMS-11"
                 R$ROP   - 4-25
                 XABOF$  - 1-4
                 XBAOF$  - Defines offsets for Allocation XAB only
                 XBDOF$  - Defines offsets for Date & Time XAB only
                 XBKOF$  - Defines offsets for Key Definition XAB only
                 XBPOF$  - Defines offsets for Protection XAB only
                 XBSOF$  - Defines offsets for Summary XAB only
                 X$HAL   - Initializes HAL field
                 X$VOL   - 5-19

                 Note  that  R$RFA  is  defined  in RMR (4-22) but does not
                 exist in the library.

                 There  are  also  a  number  of similar macros that define
                 offsets/bit values for internal or on-disk structures:-

                 ARDOF$  BDBOF$  BDB$BT  BKTOF$  BKT$BT  CTXOF$  IDXOF$
                 IDX$BT  IFAOF$  IFA$BT  IMAOF$  IMA$BT  IRAOF$  IRA$BT
                 KDXOF$  KDX$BT  TRVOF$

                 They have all been defined in Chapter I.


         RMS-11 Internals                                              Page 58





                 Finally  there  are  the  macros  invoked  by the above to
                 perform the actual operations:-

                 FIELD$ - Sets  up  offset O$yyy in currently-defined table
                          with  value of equivalent symbol ($yyy) either as
                          a byte or a word. (yyy is the field mnemonic).
                 $SEQCK - Checks    that    table   initialization   macros
                          correspond   to   table   being  initialized,  by
                          interrogating symbols like ...TBL & ...FAB.
                 $STRIP - is  a  recursive  macro  that  sets  a  series of
                          symbols  ($yyy0,  $yyy1 ...) to the values of the
                          specified arguments.
                 $UFLD$ - invokes  $SEQCK  to  check  the  validity  of the
                          definition & then sets the relevant symbol ($yyy)
                          to the specified via ..EMIT.
                 $WRDS  - simply  invokes  $SEQCK  to  check the definition
                          validity  &  then  invokes  $$LNUM  to  split the
                          specified doubleword value into two single words.
                 $$LNUM - Converts   decimal  doubleword  number  into  two
                          single  word values and assigns them (via ..EMIT)
                          to $yyy0 and $yyy1.


         RMS-11 Internals                                              Page 59





                 _____________________  _____         d)      Pool Space Definition Macros

                 Although  similar  in name, the macros used to define pool
                 space  act,  on  the  whole, in a very different way.  The
                 macros involved are:-

                 POOL$B  POOL$E  P$BDB   P$BUF   P$FAB   P$IDX   P$RAB
                 P$RABX

                 POOL$B  &  POOL$E  merely define the 'table being defined'
                 symbols  discussed  earlier.    The  remainder  (apart for
                 P$BUF)  are all similar in form in that they invoke $UFLD$
                 to   set   a   locally-defined   variable   equal  to  the
                 parameter(s) passed to the macro, invoke an internal table
                 offset  definition  macro  (e.g.  IRAOF$)  with  DEF$SZ as
                 argument  to  define  just the length, and then declare an
                 area  of  storage  in  the  relevant PSECT (all defined as
                 D,CON,GBL,REL,RW).  The precise details are as follows:-

                 Macro  Symbol Table   PSECT     Number of bytes reserved

                 P$BDB  $BDB   BDBOF$  $RMS11    $BDB*BD$BLN
                 P$FAB  $FAB   IFAOF$  $RMS15    $FAB*IF$BLN
                 P$IDX  $IDX1  IDXOF$  $RMS15    $IDX1*ID$BLN
                 P$RAB  $RAB   IRAOF$  $RMS13    $RAB*IR$BLN
                 P$RABX $RBX1  IRAOF$  $RMS13    $RAB*IR$BLN
                        $RBX2          $RMS17    <<$RBX2*2+$RBX3+1+3>
                        $RBX3                    &^C3>*$RBX1

                 P$BUF  does  use  $UFLD$  to define a symbol $BUF but then
                 simply reserves <$BUF+3>&^C3 (i.e. $BUF rounded up to next
                 doubleword boundary) bytes in PSECT $$RMS3.


         RMS-11 Internals                                              Page 60





                 ___________________________         e)      Dynamic Field Access Macros

                 Field  Access  Macros are defined in RMR Chapter 7 and are
                 meant  to  be  used  to  access fields in the user-visible
                 tables during operation.  They are:-

                 $COMPARE   - checks  that  the  field exists and is 1 or 2
                              bytes  long (by invoking $yyy$) and generates
                              the   corresponding   TST/TSTB   or  CMP/CMPB
                              instructions via ..EMIT.
                  $FETCH    - merely invokes the macro $CHKMV with the same
                              arguments and specifying 'Load'.
                  $OFF      - similar to $COMPARE but generates BIC/BICB.
                  $SET      - similar to $COMPARE but generates BIS/BISB.
                  $STORE    - merely invokes the macro $CHKMV with the same
                              arguments and specifying 'Store'.
                  $TESTBITS - similar to $COMPARE but generates BIT/BITB.

          In addition there are:-

                 $CHKMV     - a  very  complex macro that attempts to check
                              all  the  things specified in RMR (Chapter 7)
                              about  argument  types and suchlike using the
                              macros $yyy$ to check field validity & ..EMIT
                              to output the string.  It is the most complex
                              (and time-consuming) macro in the library and
                              should be avoided wherever possible.
                 $LOAD      - Simply   invokes   $FETCH   with   the   same
                              parameters.


         RMS-11 Internals                                              Page 61





                 ________________________________         f)      File and Record Operation Macros

                 These are used to initiate a file/record operation of some
                 kind.  They are:-

                 $CLOSE    $CONNECT  $CREATE   $DELETE   $DISCONNECT
                 $DISPLAY  $DSQP     $ENQP     $ERASE    $EXTEND
                 $FIND     $FLUSH    $FREE     $GET      $NXTVOL
                 $OPEN     $PUT      $QUIET    $READ     $RELEASE
                 $REWIND   $SPACE    $TRUNCATE $UPDATE   $WAIT
                 $WRITE

                 In  general  these  macros  are  described in RMR and have
                 entries  in  the  index.   For some reason a few have been
                 omitted  from  the index, even though they have entries in
                 the  manual  and some others are not in the manual at all.
                 These are:-

                 $DSQP      - Calls $RMDSQ with address of FAB.
                 $ENQP      - Calls $RMENQ with address of FAB.
                 $QUIET     - Calls $RMQUI with address of FAB.
                 $READ      - 9-3
                 $RELEASE   - Calls $RMREL with address of RAB.
                 $SPACE     - 9-6
                 $WRITE     - 9-5

                 Each  of  these  macros  invokes  in turn the macro $CALL$
                 which  implements a call to the relevant procedure with up
                 to 3 arguments.


         RMS-11 Internals                                              Page 62





                 ______         g)      Others

                 There  is also a handful of other macros in the library as
                 follows:-

                 CCML$   - Version of CCML$ using RMS I/O instead of FCS.
                 GCMLB$  - As for CCML$.
                 GCMLD$  -  "    "
                 GCML$   -  "    "
                 GCML$D  -  "    "
                 GSA$    - Initializes   GSA   address   in   Impure   Area
                           statically.  (RMR 2-8)
                 ORG$    - Generates  entries  in the Transfer Vector Table
                           in  $$RMS1  by  means  of  an internally-created
                           macro  ($PLUG$).  As soon as any organization is
                           mentioned  the entries for Open, Close, Connect,
                           Disconnect   are   inserted,   followed  by  the
                           specified operation type.  (RMR 1-5)
                 RCML$   - As for CCML$.
                 RECN$   - Initialize   Impure   Area   to   Record  Number
                           Access(?).
                 $BUFFER - Defines   a   word-aligned  buffer  of  a  given
                           length.(*)
                 $ENTRY  - Defines global entry point & debug trace.(*)
                 $FBCAL  - Calls in File Operation Macros (RMR 1-3).
                 $GETGSA - Uses  ..EMIT  to  generate  code  to extract the
                           address  of  the GSA from the Impure Area.  (RMR
                           2-9)
                 $GETSTG - Generates call to $GTSTG.(*)
                 $GNCAL  - Calls in general macros (RMR 1-3).
                 $INIT   - Uses  ..EMIT  to  generate call to $RMSIN.  (RMR
                           1-7.1)
                 $INITIF - Uses  ..EMIT  to  generate call to $RMINF.  (RMR
                           1-7.1)
                 $IOER$  - Called by $RMSTAT to define an error return.
                 $LOCALS - Defines local symbols for RMS-11.
                 $POSIZ  - Generates  offsets  for  8 words called x$POS0 -
                           x$POS7  and  for 8 bytes called x$SIZ0 - z$SIZ7,
                           and  defines symbols x$POS and x$SIZ pointing to
                           the start of each.
                 $RBCAL  - Calls in Record Operation Macros (RMR 1-3).
                 $RETURN - Just does an RTS PC.(*)
                 $RMSDT  - Null macro.(*)
                 $RMSTAT - Defines RMS-11 return codes.  (RMR 1-4)
                 $SETGSA - Does  reverse of $GETGSA, but also has hordes of
                           clever  code  to  check  on type of input.  (RMR
                           2-9)
                 $SETRECN- Generates  code  to  set access to Record Number
                           Mode (?).
                 $STGDPLY- Generates call to $DSTG.(*)
                 $TSTPT  - Incorporates/Calls a 'Test Point'.(*)

                 Those marked (*) appear to be hangovers from the debugging
                 system  and  are  never  used by any of the others, though
                 note that $GNCAL will pull in $BUFFER & $RETURN.

         RMS-11 Internals                                              Page 63





                 ________________         h)      Debugging System

                 There  would appear to be a fairly comprehensive debugging
                 system designed for use with RMS-11 macros.  Unfortunately
                 most  of the routines associated with it are not supplied.
                 However, one small remnant of it exists that is still very
                 usable, and that works as follows:-

                 Each  of  the  'offset  definition' macros BDBOF$, IDXOF$,
                 IFAOF$,  IMAOF$,  IRAOF$,  KDXOF$, LCBOF$, NAMOF$, FABOF$,
                 RABOF$,  XABOF$  references  a  symbol called R$$TST.  The
                 full  use  of this is now lost, but if it is set to 3 then
                 the  macros  generate  a set of ASCII strings suitable for
                 input  to  $EDMSG defining all the fields in the table and
                 their  values.   These strings are set up in PSECT $STRU3.
                 In  addition  for  each  table a 4-word entry is set up in
                 $STRU1 defining:-

                         Name of table in RAD50 (2 words)
                         Address  of  string  for  $EDMSG  output  (must be
                                 called SY.ADR)
                         Address of format string for $EDMSG

                 Thus  by searching PSECT $STRU1 for the relevant structure
                 definition,  one  can  obtain  a  formatted  dump  of  any
                 structure in the program.  The only major overhead is that
                 the  ASCII  strings  are, naturally, rather large and also
                 need  a  large  output  buffer.   The relevant structures,
                 their  'structure names' and the size of the corresponding
                 ASCII format strings (in decimal bytes) are:-

                 Structure Type                   Name        Size

                 Buffer Descriptor Block          BDB          184
                 Internal Key Descriptor          IDXDSC       519
                 Internal File Access Block       IFAB         515
                 Impure Area                      IMAREA      1287
                 Internal Record Access Block     IRAB         305
                 Indexed Files Prologue           PDXDSC       701
                 Log Control Block                LCB           81
                 Name Block                       NAM          299
                 File Access Block                FAB          725
                 Record Access Block              RAB          730
                 Key XAB                          KEYXAB       503
                 Date & Time XAB                  DATXAB       221
                 Protection XAB                   PROXAB       101
                 Allocation XAB                   ALLXAB       259
                 Summary XAB                      SUMXAB       109

                                                  Total:      6539


         RMS-11 Internals                                              Page 64





                 A  sample  routine  that  might  be  written  to  use this
                 debugging aid is listed below:-

                 .MCALL  QIOW$S
                 .PSECT  $STRU1
         TABSTR:
                 .PSECT
         R$$TST=3
                 .MCALL  FABOF$,RABOF$,XABOF$,BDBOF$
                 .MCALL  IDXOF$,IFAOF$,IMAOF$,IRAOF$
                 .MCALL  KDXOF$,LCBOF$,NAMOF$
                 BDBOF$  RMS$L
                 IDXOF$  RMS$L
                 IFAOF$  RMS$L
                 IMAOF$  RMS$L
                 IRAOF$  RMS$L
                 KDXOF$  RMS$L
                 LCBOF$  RMS$L
                 NAMOF$  RMS$L
                 FABOF$  RMS$L
                 RABOF$  RMS$L
                 XABOF$  RMS$L
                 .PSECT  $STRU1
         TABEND:
                 .PSECT
         BUFSIZ=1536.
         ;
         ; On entry to this routine:-
         ;       R0 holds first three chars of structure name in RAD50
         ;       R1 holds last three chars of structure name in RAD50
         ;       R2 holds the address of the structure
         ;
         ; The output is directed to LUN 5
         ;
         DEBUG::
                 CALL    $SAVAL          ; Save all registers
                 MOV     #TABSTR,R4      ; Get table start address
                 MOV     #<TABEND-TABSTR>/8.,R5  ; Get number of elements
                 BEQ     90$             ; If EQ none (??) exit
         ;
         10$:
                 CMP     R0,(R4)+        ; First half the same?
                 BNE     20$             ; If NE no - try the next one
                 CMP     R1,(R4)         ; Second half the same?
                 BEQ     30$             ; If EQ yes - we've got it!
         ;
         20$:
                 ADD     #6,R4           ; No - set to next element
                 SOB     R5,10$          ; If any more - check next
                 BR      90$             ; Structure not found - exit

         RMS-11 Internals                                              Page 65





         ;
         30$:
                 TST     (R4)+           ; Set to next word
                 MOV     (R4)+,R0        ; Get the output buffer address
                 MOV     (R4)+,R1        ; Get the format string address
                 CALL    $EDMSG          ; Format the string
                 CMP     R1,#BUFSIZ      ; Overflowed our buffer?
                 BLE     40$             ; If LE no - carry on
                 HALT                    ; Yes - crash
         40$:
                 QIOW$S  #IO.WLB,#5,#1,,,,<#SY.ADR,R1>
         90$:
                 RETURN
                 .PSECT  ZZZ
         SY.ADR: .BLKB   BUFSIZ          ; Buffer for $EDMSG
                 .END

         RMS-11 Internals                                              Page 66





                 _____________________         i)      Macro Cross-Reference

                 As  has  already  been  mentioned  much of the code in the
                 macros  is  relatively  superfluous (such as ..EMIT).  For
                 the  user  who wishes to modify some of the macros to make
                 them  more efficient the following 'cross-reference' table
                 of the macros in RMSMAC.MLB might be useful:-

         $$LNUM  - $WRDS
         $CALL$  - $CLOSE      $CONNECT    $CREATE     $DELETE
                   $DISCONNECT $DISPLAY    $DSQP       $ENQP
                   $ERASE      $EXTEND     $FIND       $FLUSH
                   $FREE       $GET        $NXTVOL     $OPEN
                   $PUT        $QUIET      $READ       $RELEASE
                   $REWIND     $SPACE      $TRUNCATE   $UPDATE
                   $WAIT       $WRITE
         $CHKMV  - $FETCH      $STORE
         $EMSTG  - BDBOF$      FABOF$      IDXOF$      IFAOF$
                   IMAOF$      IRAOF$      KDXOF$      LCBOF$
                   NAMOF$      RABOF$      RMS$L       XABOF$
         $FETCH  - $LOAD
         $IOER$  - $RMSTAT
         $POSIZ  - IDXOF$      KDXOF$      XABOF$
         $SEQCK  - $UFLD$      $WRDS       FAB$B       FAB$E
                   LCB$B       LCB$E       NAM$B       NAM$E
                   POOL$B      POOL$E      RAB$B       RAB$E
                   X$POS       X$SIZ       XAB$B       XAB$E
         $STRIP  - X$POS       X$SIZ
         $UFLD$  - F$BKS       F$BLS       F$BPA       F$BPS
                   F$CTX       F$DEQ       F$DNA       F$DNS
                   F$FAC       F$FNA       F$FNS       F$FOP
                   F$FSZ       F$JNL       F$LCH       F$MRS
                   F$NAM       F$ORG       F$RAT       F$RFM
                   F$RTV       F$SHR       F$XAB       L$AIR
                   L$BIR       L$CTX       N$ESA       N$ESS
                   N$RLF       N$RSA       N$RSS       P$BDB
                   P$BUF       P$FAB       P$IDX       P$RAB
                   P$RABX      R$CTX       R$FAB       R$KBF
                   R$KRF       R$KSZ       R$MBC       R$MBF
                   R$RAC       R$RBF       R$RHB       R$ROP
                   R$RSZ       R$UBF       R$USZ       X$AID
                   X$ALN       X$AOP       X$BKZ       X$DAN
                   X$DEQ       X$DFL       X$DTP       X$FLG
                   X$HAL       X$IAN       X$IFL       X$KNM
                   X$LAN       X$NUL       X$NXT       X$PRG
                   X$PRJ       X$PRO       X$REF       X$VOL
         $WRDS   - F$ALQ       F$MRN       R$BKT       X$ALQ
                   X$LOC
         $yyy$   - $CHKMV      $COMPARE    $OFF        $SET
                   $TESTBITS
         'BIT'   - BDB$BT      BKT$BT      CTXOF$      FAB$BT
                   IDX$BT      IFA$BT      IMA$BT      IRA$BT
                   KDX$BT      RAB$BT      XAB$BT

         RMS-11 Internals                                              Page 67





         'OFF'   - $POSIZ      ARDOF$      BDBOF$      BKTOF$
                   CTXOF$      FABOF$      IDXOF$      IFAOF$
                   IMAOF$      IRAOF$      KDXOF$      LCBOF$
                   NAMOF$      RABOF$      TRVOF$      XABOF$
         ..EMIT  - $$LNUM      $BUFFER     $CALL$      $CHKMV
                   $COMPARE    $GETGSA     $INIT       $INITIF
                   $OFF        $RETURN     $SET        $SETGSA
                   $TESTBITS   $UFLD$      FABDF$      FIELD$
                   LCB$E       NAM$E       NAMDF$      RAB$E
                   RABDF$      XAB$E       XABDF$
         BDBOF$  - P$BDB
         DFIN$G  - $IOER$      $RMSTAT
         DFIN$L  - $IOER$      $RMSTAT
         DPSECT  - GSA$        ORG$        POOL$B      RECN$
         FAB$B   - GCMLB$
         FAB$BT  - FAB$B
         FABDF$  - FAB$B
         FABOF$  - FABDF$      GCML$D
         FIELD$  - FAB$E       LCB$E       NAM$E       RAB$E
                   XAB$E
         GCML$D  - GCMLD$
         GCMLD$  - GCML$       GCMLB$
         IDXOF$  - P$IDX
         IFAOF$  - P$FAB
         IMAOF$  - $GETGSA     $SETGSA     $SETRECN    GSA$
                   RECN$
         IRAOF$  - P$RAB       P$RABX
         LCBDF$  - LCB$B
         LCBOF$  - LCBDF$
         NAM$B   - GCMLB$
         NAMDF$  - NAM$B
         NAMOF$  - GCML$D      NAMDF$
         RAB$B   - GCMLB$
         RAB$BT  - RAB$B
         RABDF$  - RAB$B
         RABOF$  - GCML$D      RABDF$
         RMS$L   - ARDOF$      BDBOF$      FABOF$      IDXOF$
                   IFAOF$      IRAOF$      KDXOF$      LCBOF$
                   NAMOF$      RABOF$      RMS$G       XABOF$
         STRU$B  - BDBOF$      FABOF$      IDXOF$      IFAOF$
                   IMAOF$      IRAOF$      KDXOF$      LCBOF$
                   NAMOF$      RABOF$      XABOF$
         STRU$E  - BDBOF$      FABOF$      IDXOF$      IFAOF$
                   IMAOF$      IRAOF$      KDXOF$      LCBOF$
                   NAMOF$      RABOF$      XABOF$
         TRVOF$  - ORG$
         XAB$BT  - XAB$B
         XABDF$  - XAB$B
         XABOF$  - XABDF$
         XBAOF$  - XABOF$
         XBDOF$  - XABOF$
         XBKOF$  - XABOF$
         XBPOF$  - XABOF$
         XBSOF$  - XABOF$

         RMS-11 Internals                                              Page 68






                 Where $yyy$ means that a field mnemonic yyy is passed as a
                 parameter  and  it's  equivalent  macro  is invoked, 'BIT'
                 means  that  one of the 'value definition' macros (DFIN$L,
                 DFIN$G)  is  passed  as an argument and is used, and 'OFF'
                 means  that  one of the 'offset definition' macros (RMS$L,
                 RMS$G, DEF$SZ) is passed as an argument and is used.


         RMS-11 Internals                                              Page 69





                 _________________  _____         j)      Doing without the Macros

                 It  can  at  times  be very frustrating waiting for a long
                 time  for  an  assembly  of  a  program  using RMS-11 from
                 MACRO-11.    At  first  sight  it would seem impossible to
                 write such a program without using the macros, but in fact
                 it is quite easy.

                 The  first problem lies in defining the FABs and RABs.  As
                 there  are  various  default values which are difficult to
                 remember  each  time,  it  is convenient here to use a new
                 macro,  say  called  FABDEF,  to reserve the space for and
                 initialize a FAB.  An example of such a macro might be:-

                 .MACRO FABDEF
                 .MCALL  FABOF$,FAB$BT
                         FABOF$  RMS$L
                         FAB$BT  DFIN$L
                 ...T1=.
                         .REPT   FB$BLN/2
                         .WORD   0
                         .ENDR
                 ...T2=.
                 .=...T1+O$FAC
                         .BYTE   FB$GET
                 .=...T1+O$SHR
                         .BYTE   FB$GET
                 .=...T1+O$ORG
                         .BYTE   FB$SEQ
                 .=...T1+O$RFM
                         .BYTE   FB$VAR
                 .=...T1+O$BID
                         .BYTE   FB$BID
                 .=...T1+O$BLN
                         .BYTE   FB$BLN
                 .ENDM FABDEF

                 Note  that this macro also calls in and invokes the macros
                 FABOF$  and  FAB$BT  to  define  all necessary offsets and
                 values  for  the  FAB.  It also defines two symbols (...T1
                 and  ...T2)  to  represent the start and end of the FAB so
                 that  other  fields  can  be  initialized.  Similar macros
                 could be defined for RABs (Asynchronous & Synchronous) and
                 for the various XABs.

                 Next  requirement  is  to  define pool-space, which merely
                 requires  defining  the  lengths  of the relevant internal
                 tables  (e.g.  IRAOF$  DEF$SZ)  and  then  calculating the
                 lengths to be reserved in each PSECT.

                 Finally,  in  the  data section, it is necessary to define
                 the  transfer  vectors, but by examining the layout of the
                 transfer  vector  table  given  previously, this is really
                 easy.

         RMS-11 Internals                                              Page 70






                 In   the   code   section   itself   there  are  only  two
                 requirements.  Firstly it is necessary to call the various
                 RMS-11  routines,  and  these  are called using a standard
                 FORTRAN-compatible   interface   (i.e.   R5  points  to  a
                 parameter  block).  Secondly examination/storage of fields
                 in  the  various  tables can be done simply by remembering
                 that the offset of any field yyy is defined by O$yyy.

                 The  following  is  the  example  DEMO.RMS  given  in  RMR
                 (Appendix  B)  written  without  the RMS-11 macros (or the
                 comments).

                         .MCALL  FABDEF, RABDEF, DEF$SZ, RMS$L, DFIN$L
                         .MCALL  IRAOF$, IFAOF$, TRVOF$, BDBOF$
                         .MCALL  EXIT$S
                         TRVOF$  RMS$L
                         BDBOF$  DEF$SZ
                         IRAOF$  DEF$SZ
                         IFAOF$  DEF$SZ
                 ;
                 FAB1:   FABDEF
                 .=...T1+O$FNA
                         .WORD   NAME1
                 .=...T1+O$FNS
                         .WORD   9.
                 .=...T1+O$LCH
                         .BYTE   1
                 .=...T2
                 ;
                 NAME1:  .ASCII  /FILE1.DAT/
                         .EVEN
                 ;
                 FAB2:   FABDEF
                 .=...T1+O$FNA
                         .WORD   NAME2
                 .=...T1+O$FNS
                         .WORD   9.
                 .=...T1+O$LCH
                         .BYTE   2
                 .=...T1+O$FAC
                         .BYTE   FB$PUT
                 .=...T2
                 ;
                 NAME2:  .ASCII  /FILE2.DAT/
                         .EVEN

         RMS-11 Internals                                              Page 71





                 ;
                 RAB1:   RABDEF
                 .=...T1+O$FAB
                         .WORD   FAB1
                 .=...T1+O$RAC
                         .BYTE   RB$SEQ
                 .=...T1+O$UBF
                         .WORD   RECBUF
                 .=...T1+O$USZ
                         .WORD   500.
                 .=...T1+O$RHB
                         .WORD   HEDBUF
                 .=...T2
                 ;
                 RAB2:   RABDEF
                 .=...T1+O$FAB
                         .WORD   FAB2
                 .=...T1+O$RAC
                         .BYTE   RB$SEQ
                 .=...T1+O$RBF
                         .WORD   RECBUF
                 .=...T1+O$RSZ
                         .WORD   500.
                 .=...T1+O$RHB
                         .WORD   HEDBUF
                 .=...T2
                 ;
                 RECBUF: .BLKW   250.
                 HEDBUF: .BLKW   128.
                 ;
                         .PSECT  $RMS15,D,CON,GBL,REL,RW
                         .BLKB   <2*IF$BLN>
                         .PSECT  $RMS13,D,CON,GBL,REL,RW
                         .BLKB   <2*IR$BLN>
                         .PSECT  $RMS11,D,CON,GBL,REL,RW
                         .BLKB   <2*BD$BLN>
                         .PSECT  $$RMS3,D,CON,GBL,REL,RW
                         .BLKB   1024.
                         .PSECT  $$RMS1,D,OVR,GBL,REL,RW
                 ;
                 ...TV.=.
                 .=...TV.+TV$OPE+0
                         .WORD   $OPE1E
                 .=...TV.+TV$CRE+0
                         .WORD   $CRE1E
                 .=...TV.+TV$CLO+0
                         .WORD   $CLO1E
                 .=...TV.+TV$CON+0
                         .WORD   $CON1E
                 .=...TV.+TV$DIS+0
                         .WORD   $DIS1E
                 .=...TV.+TV$GET+0
                         .WORD   $GET1E
                 .=...TV.+TV$PUT+0
                         .WORD   $PUT1E

         RMS-11 Internals                                              Page 72





                         .PSECT
                 ;
                 START:
                         JSR     PC,$RMSIN
                         MOV     #FAB1,-(SP)
                         MOV     #1,-(SP)
                         MOV     SP,R5
                         JSR     PC,$RMOPE
                         ADD     #4,SP
                         MOV     #FAB1,R0
                         TST     O$STS(R0)
                         BGT     1$
                         JSR     PC,ERROR
                 1$:     MOV     #FAB2,R1
                         MOVB    FAB1+O$RAT,FAB2+O$RAT
                         MOVB    FAB1+O$RFM,FAB2+O$RFM
                         MOVB    FAB1+O$FSZ,FAB2+O$FSZ
                         MOV     FAB1+O$MRN,FAB2+O$MRN
                         MOV     FAB1+O$MRN+2,FAB2+O$MRN+2
                         MOV     FAB1+O$MRS,FAB2+O$MRS
                         MOV     FAB1+O$ALQ,FAB2+O$ALQ
                         MOV     FAB1+O$ALQ+2,FAB2+O$ALQ+2
                         MOV     R1,-(SP)
                         MOV     #1,-(SP)
                         MOV     SP,R5
                         JSR     PC,$RMCRE
                         ADD     #4,SP
                         TST     O$STS(R1)
                         BGT     2$
                         JSR     PC,ERROR
                 2$:     MOV     #RAB1,R0
                         MOV     #RAB2,R1
                         MOV     R0,-(SP)
                         MOV     #1,-(SP)
                         MOV     SP,R5
                         JSR     PC,$RMCON
                         ADD     #4,SP
                         TST     O$STS(R0)
                         BGT     3$
                         JSR     PC,ERROR
                 3$:     MOV     R1,-(SP)
                         MOV     #1,-(SP)
                         MOV     SP,R5
                         JSR     PC,$RMCON
                         ADD     #4,SP
                         TST     O$STS(R1)
                         BGT     4$
                         JSR     PC,ERROR
                 4$:     MOV     R0,-(SP)
                         MOV     #1,-(SP)
                         MOV     SP,R5
                         JSR     PC,$RMGET
                         ADD     #4,SP

         RMS-11 Internals                                              Page 73





                         CMP     #ER$EOF,O$STS(R0)
                         BEQ     DONE
                         TST     O$STS(R0)
                         BGT     5$
                         JSR     PC,ERROR
                 5$:     MOV     O$RSZ(R0),O$RSZ(R1)
                         MOV     R1,-(SP)
                         MOV     #1,-(SP)
                         MOV     SP,R5
                         JSR     PC,$RMPUT
                         ADD     #4,SP
                         TST     O$STS(R1)
                         BGT     6$
                         JSR     PC,ERROR
                 6$:     BR      4$
                 DONE:   MOV     #FAB1,-(SP)
                         MOV     #1,-(SP)
                         MOV     SP,R5
                         JSR     PC,$RMCLO
                         ADD     #4,SP
                         TST     FAB1+O$STS
                         BGT     1$
                         JSR     PC,ERROR
                 1$:     MOV     #FAB2,-(SP)
                         MOV     #1,-(SP)
                         MOV     SP,R5
                         JSR     PC,$RMCLO
                         ADD     #4,SP
                         TST     FAB2+O$STS
                         BGT     2$
                         JSR     PC,ERROR
                 2$:
                 ERROR:  EXIT$S
                         .END    START

                 As  was  expected  this  resulted  in  a noticeably faster
                 assembly  (186 seconds for the version with RMS-11 macros,
                 95  seconds  for  the version without).  What was slightly
                 more  surprising  was  that  it also resulted in a smaller
                 program  (2702 octal bytes versus 2616 in the code PSECT).
                 The  reason  for  this proved to be twofold.  Firstly, the
                 macros  such  as $CLOSE always save R5 on the stack before
                 generating  the  call,  though in this program R5 is never
                 used.    Secondly,  to move a byte from one FAB to another
                 FAB it is necessary to do:-
                         $FETCH  R2,RAT,R0
                         $STORE  R2,RAT,R1
                 which expands to:-
                         CLR     R2
                         BISB    O$RAT(R0),R2
                         MOVB    R2,O$RAT(R1)
                 which  takes  up  three  instructions  and  five words, as
                 opposed to:-
                         MOVB    O$RAT(R0),O$RAT(R1)
                 which takes up one instruction and three words.

         RMS-11 Internals                                              Page 74





                                     __________                                     CHAPTER IV

                                ___________________                                RMS-11 Subroutines.

                 As  with  macros  RMS-11  uses  a  bewildering  number  of
                 subroutines,   few   of  which  are  documented  anywhere.
                 Although  some  information can be gleaned from the RMS-11
                 Prototype  ODL  it  is  still not immediately obvious what
                 each module does, or under what conditions it is needed.

                 It  is  generally  true  that  all modules are of the form
                 Rnxxxx  where  n  defines  the  relevant  file  type  (0 =
                 General,  1  =  Sequential, 2 = Relative, 3 = Indexed) and
                 xxxx is a mnemonic for the module's purpose, but even this
                 rule is not always rigidly adhered to.

                 The  following  table gives a brief list of all the RMS-11
                 modules,  their  size (in decimal bytes), what activity in
                 the  task  will  result  in  their  inclusion, and a brief
                 description of their purpose.  The reference [All] implies
                 that  the  module  will  be  included whatever the program
                 does,  and  assumes  that the program will at least open a
                 file  (of  some  kind)  and attach to a stream.  There are
                 also two abbreviations used in the table:-
                         $Misc   =  $FREE or $FLUSH or $TRUNCATE or $REWIND
                                   or $NXTVOL or $RELEASE or $SPACE
                         $D/P/U  = $DELETE or $PUT or $UPDATE
                         UDR     = User Data Record


                 ARITH   56      [All]
                         Same as SYSLIB routines, but different PSECTs.
                 DARITH  64      [All]
                         Same as SYSLIB routines, but different PSECTs.
                 RMSSYM  0       [All]
                         Defines all RMS symbols globally.
                 RQLCB   160     [All]
                         Internal Buffer Allocation Control.
                 R0ACBB  96      [All]
                         Allocate Control Blocks & I/O Buffers.
                 R0ALBD  36      [All]
                         Allocate BDB and link to IFAB chain.
                 R0ALBS  26      [All]
                         Allocate BDBs & Buffers for Stream.
                 R0ALDB  24      [All]
                         Allocate initial BDB & I/O Buffer.
                 R0ALIO  80      [All]
                         Allocate I/O Buffer & initialize BDB.
                 R0ASLN  190     [All]
                         Assign LUN & get Device Characteristics.
                 R0AUTO  0       [All]
                         Stuffs CALL @#$AUTO in Impure Area at Y$AUTO.

         RMS-11 Internals                                              Page 75





                 R0CACH  606     [All]
                         Read a Block & perform 'cache' function.
                         Check for Idle Streams.
                 R0CCLN  168     [All]
                         Common  Disconnect  Code  -  returning  buffers  &
                         suchlike.
                 R0CKSM  52      [All]
                         Calculate/Compare/Store Checksum.
                 R0CLCM  158     [All]
                         Common  Close Routines - returning buffers to pool
                         & suchlike.
                 R0CLOS  14      [$CLOSE]
                         User-RMS Interface for $CLOSE.
                 R0CMKY  448     [Record I/O on Indexed Files]
                         Compare  User  Key  to Index/Data Record & to Null
                         Key.
                 R0CONN  14      [$CONNECT]
                         User-RMS Interface for $CONNECT.
                 R0CREA  60      [$CREATE]
                         User-RMS Interface for $CREATE.
                 R0CRFL  496     [$CREATE]
                         Common  Create Routines - Create File / Enter File
                         in Directory / Access File / Replace Existing File
                         where Relevant.
                 R0CRXI  64      [$CREATE]
                         Common Exit for $CREATE - Return buffers to pool.
                 R0DELE  14      [$DELETE]
                         User-RMS Interface for $DELETE.
                 R0DISC  14      [$DISCONNECT]
                         User-RMS Interface for $DISCONNECT.
                 R0DISP  26      [$DISPLAY]
                         User-RMS Interface for $DISPLAY.
                 R0DPYC  1354    [All]
                         Common  processor  for  Display Function (but also
                         used by Open).
                 R0ERAS  42      [$ERASE]
                         User-RMS Interface for $ERASE.
                 R0ERFL  176     [$ERASE]
                         Erase a file from a directory.
                 R0EXEC  690     [Asynchronous I/O]
                         Asynchronous  Routines  for  issuing Read Requests
                         and suchlike (as defined in the Impure Area).
                 R0EXSY  354     [Synchronous I/O]
                         Synchronous version of R0EXEC.
                 R0EXTD  632     [All]
                         Common Routine to Extend a File.
                 R0EXTE  18      [$EXTEND]
                         User-RMS Interface for $EXTEND.
                 R0EXT0  1058    [$EXTEND]
                         Control Module for $EXTEND.
                 R0FBDB  66      [$FLUSH/$FREE/$NXTVOL/$RELEASE/$SPACE]
                         User-RMS  Interface  for  $FLUSH,  $FREE, $NXTVOL,
                         $RELEASE & $SPACE.

         RMS-11 Internals                                              Page 76





                 R0FIND  14      [$FIND]
                         User-RMS Interface for $FIND.
                 R0FREE  312     [$Misc]
                         Processing modules for $FLUSH, $FREE & $RELEASE.
                 R0FSEI  0       [-]
                         Dummy Module.
                 R0FSET  0       [-]
                         Dummy Module.
                 R0GCML  1116    [GCML$ etc.]
                         Handles GCML processing.
                 R0GET   14      [$GET]
                         User-RMS Interface for $GET.
                 R0GETB  172     [Indexed Files]
                         Read Index Data Bucket & Check Check Byte, Address
                         Sample and Control Flags.
                 R0GPTR  100     [Record I/O on Indexed Files]
                         Build Bucket Pointer for Index/Data Records.
                 R0IDPB  30      [All]
                         Zero the QIO DPB & return its address.
                 R0IFLF  32      [All]
                         Dispatch Routine for ORG-specific File Functions.
                 R0IMPA  0       [All]
                         Defines  some global symbols & initializes some of
                         the Impure Area.
                 R0INIT  200     [All]
                         Initializes the Impure Area.
                 R0MAGT  224     [$Misc]
                         Rewind/Space Magnetic Tapes.
                 R0MAPC  74      [All]
                         Map Buffers.
                 R0MDAT  92      [All]
                         Move bytes/words of data.
                 R0MFNB  254     [All]
                         Fill in FNB/FIRQB for Create/Open.
                 R0MKWA  90      [All]
                         Allocate  Work  Area  to  hold  Name Block, FNB, &
                         Attribute List.
                 R0OPEN  76      [$OPEN]
                         User-RMS Interface for $OPEN.
                 R0OPFL  394     [All]
                         Common  Open  Routines to Find & Access a File and
                         fill in the FAB.
                 R0PRFN  210     [All]
                         Common  Filename  Processing  -  Expand File Name,
                         Assign LUN, Set Up Work Area, etc.
                 R0PUT   14      [$PUT]
                         User-RMS Interface for $PUT.
                 R0RD50  124     [All]
                         Convert ASCII string to RAD50.
                 R0RECN  272     [-]
                         ???
                 R0REWI  18      [$REWIND]
                         User-RMS Interface for $REWIND.

         RMS-11 Internals                                              Page 77





                 R0RLCH  496     [All]
                         Buffer Cache Release Routine.
                 R0RLSB  150     [Indexed Files]
                         Calculate  New  Check  Byte  &  Release Bucket for
                         Indexed Files.
                 R0RMSA  34      [All]
                         RMS Crash Module.
                 R0RMSE  68      [All]
                         Common  Exit  Code to Invoke Completion Routines &
                         Return to User.
                 R0RSEI  0       [-]
                         Dummy Module.
                 R0RSES  350     [Synchronous I/O]
                         Synchronous    Validity   Check   prior   to   RAB
                         processing.
                 R0RSET  428     [Asynchronous I/O]
                         Asynchronous version of R0RSEI.
                 R0RTCB  72      [All]
                         Return Control Block/I/O Buffers to Pool.
                 R0RTDB  88      [All]
                         Return BDB & any associated buffers to pool.
                 R0RWBF  472     [All]
                         Read/Write VBNs associated with BDB.  Perform Read
                         Ahead/Write Behind.
                 R0RWBI  438     [$READ/$WRITE]
                         Block I/O Processing.
                 R0RWBL  30      [$READ/$WRITE]
                         User-RMS Interface for $READ & for $WRITE.
                 R0RWIN  206     [$REWIND]
                         Processing Module for $REWIND.
                 R0RXAC  710     [All]
                         Common  Module  to Access File & Read Statistics &
                         Attributes.
                 R0RXCR  540     [$CREATE]
                         Common  Routine  to  Create  File  on  RSX11M  and
                         perform any Placement Control.
                 R0RXDI  422     [All]
                         Common  Routine  to  get  Directory File ID and to
                         Find/Enter/Remove File in Directory.
                 R0RXMD  66      [$CREATE/$ERASE]
                         Common  Routine  to  Mark  a  File  for  Delete on
                         RSX11M.
                 R0SAVR  0       [-]
                         Dummy Module.
                 R0TRUN  18      [$TRUNCATE]
                         User-RMS Interface for $TRUNCATE.
                 R0UNLK  136     [All]
                         Unlock BDB & its VBNs.
                 R0UPDA  14      [$UPDATE]
                         User-RMS Interface for $UPDATE.
                 R0WAIT  102     [$WAIT]
                         User-RMS Interface for $WAIT.

         RMS-11 Internals                                              Page 78





                 R0WATB  146     [Asynchronous I/O]
                         Asynchronous  Routine to wait for BDB resource and
                         to dequeue next entry in Wait For List.
                 R0WATR  102     [$Misc]
                         Write File Attributes.
                 R0WTBS  4       [Synchronous I/O]
                         Synchronous Version of R0WATB.
                 R0XPFN  1272    [All]
                         Build Expanded Filespec from given filename.
                 R1CKEF  46      [Record I/O - Sequential File]
                         Check for End-of-File on Sequential File.
                 R1CLOS  204     [Sequential File]
                         Close Module for Sequential Files.
                 R1CONP  244     [Sequential File]
                         Connect Module for Sequential Files.
                 R1CRCK  402     [$CREATE - Sequential File]
                         Validity  Checking  Prior to Create for Sequential
                         Files.
                 R1CRFL  56      [$CREATE - Sequential File]
                         Create Module for Sequential Files.
                 R1DELE  20      [Record I/O - Sequential File]
                         Delete Record for Sequential Files.
                 R1DISC  56      [Sequential File]
                         Disconnect Module for Sequential Files.
                 R1GBLD  1010    [$GET/$FIND - Sequential File]
                         Perform  Get/Find  on Block/Record Oriented Device
                         for Sequential Files.
                 R1GET   288     [$GET/$FIND - Sequential File]
                         Get/Find for Sequential Files.
                 R1GSET  102     [$GET/$FIND - Sequential File]
                         Validity  Checking  before Get/Find for Sequential
                         Files.
                 R1NXBK  286     [All]
                         Common  Routine  to  get a specific/the next block
                         and map to it.
                 R1OPFL  202     [Sequential File]
                         Open Module for Sequential Files.
                 R1PBLD  754     [$PUT - Sequential File]
                         Perform Put-Sequential for Block Device.
                 R1PSET  240     [$PUT/$UPDATE - Sequential File]
                         Validity  Checking  for  Put/Update for Sequential
                         Files.
                 R1PUNR  284     [$PUT - Sequential File]
                         Perform Put-Sequential for Record Device.
                 R1PUT   100     [$PUT - Sequential File]
                         Perform Put Operation for Sequential Files.
                 R1RLBK  234     [All]
                         Release Block & Extend if Necessary.
                 R1TRUN  196     [$TRUNCATE]
                         Truncate a Sequential File.
                 R1UBLD  332     [$UPDATE - Sequential File]
                         Perform  Update  on  Block  Device  for Sequential
                         Files.

         RMS-11 Internals                                              Page 79





                 R1UPDA  98      [$UPDATE - Sequential File]
                         Update Operation for Sequential Files.
                 R1WTLS  138     [All]
                         Common Routine to write out last block in file.
                 R2BFMT  272     [$CREATE/$PUT - Relative & $EXTEND - All]
                         Routine to Format a Bucket.
                 R2CALC  90      [Record I/O - Relative, & $Misc - All]
                         Calculate Address of Record in Relative File.
                 R2CLOS  40      [Relative File]
                         Close Module for Relative Files.
                 R2CONP  202     [Relative File]
                         Connect Module for Relative Files.
                 R2CRCK  348     [$CREATE - Relative File]
                         Validity  Checking  Prior  to  Create for Relative
                         Files.
                 R2CRFL  64      [$CREATE - Relative File]
                         Create Module for Relative Files.
                 R2DELE  124     [$DELETE - Relative File]
                         Delete Record for Relative Files.
                 R2DISC  24      [Relative File]
                         Disconnect Module for Relative Files.
                 R2EXTD  300     [$PUT - Relative File]
                         Extend Relative File & Update Prologue.
                 R2FIND  592     [Record I/O - Relative File]
                         Find record in Relative File.
                 R2GET   358     [$GET/$DELETE/$UPDATE - Relative File]
                         Get record in Relative File.
                 R2GSET  178     [Record I/O - Relative File]
                         Validity  Checking  prior to Get/Find for Relative
                         Files.
                 R2IOCK  374     [Record I/O - Relative File]
                         Read/Write/Release Bucket for Relative Files.
                 R2OPFL  192     [Relative File]
                         Open Module for Relative Files.
                 R2PSET  188     [$PUT/$UPDATE - Relative File]
                         Validity Checking prior to Put for Relative Files.
                 R2PUT   266     [$PUT - Relative File]
                         Put record into Relative File.
                 R2UPDA  228     [$UPDATE - Relative File]
                         Update record in Relative File.
                 R2WPLG  370     [$CREATE - Relative File]
                         Write  File  Prologue  &  Initialize Pre-Allocated
                         Buckets for Relative Files.
                 R3ALOC  926     [$D/P/U - Indexed File]
                         Allocate  required  Buckets  for Index/Data Levels
                         for Indexed Files.
                 R3BFMT  64      [$D/P/U -Indexed File]
                         Format and Initialize Indexed File Bucket.
                 R3BRRV  578     [$D/P/U -Indexed File]
                         Build  Buffer of RRVs to update after Indexed File
                         Split.
                 R3BSPL  438     [$D/P/U -Indexed File]
                         Perform Split of Data Level UDR Bucket for Indexed
                         Files.

         RMS-11 Internals                                              Page 80





                 R3BSRT  8       [$D/P/U -Indexed File]
                         Sort IDs in use in Bucket and Find Those Available
                         for Indexed Files.
                 R3CLOS  88      [Indexed File]
                         Close Module for Indexed Files.
                 R3CONP  224     [Indexed File]
                         Connect Module for Indexed Files.
                 R3CRCK  662     [$CREATE - Indexed File]
                         Validity Check Prior to Create for Indexed Files.
                 R3CRFL  100     [$CREATE - Indexed File]
                         Create Module for Indexed Files.
                 R3DELE  284     [$DELETE/$UPDATE - Indexed File]
                         Delete Record from Indexed File.
                 R3DISC  84      [Indexed File]
                         Disconnect Module for Indexed Files.
                 R3DLSI  486     [$D/P/U - Indexed File]
                         Delete  SIDR  entry for current record for Indexed
                         Files.
                 R3DSET  68      [$DELETE/$UPDATE - Indexed File]
                         Validity  Checking  prior  to  Delete  for Indexed
                         Files.
                 R3FIND  154     [$GET/$FIND - Indexed File]
                         Find Record in Indexed File.
                 R3FNDR  410     [Record I/O - Indexed File]
                         Find Record by key in Indexed File.
                 R3FPAT  222     [Record I/O - Indexed File]
                         Follow  path  from  Root  of  Indexed File to Data
                         bucket & update if needed.
                 R3FRFA  70      [Record I/O - Indexed File]
                         Find Record by RFA in Indexed File.
                 R3FRKE  574     [$GET/$FIND - Indexed File]
                         Find Record by key in Indexed File.
                 R3FROO  256     [Record I/O - Indexed File]
                         Fetch Root Bucket for Indexed Files.
                 R3FRRF  114     [$GET/$FIND - Indexed File]
                         Find Record via its RRV for Indexed Files.
                 R3FRRV  304     [Record I/O - Indexed File]
                         Find Record by its RRV for Indexed Files.
                 R3FRSE  76      [$GET/$FIND - Indexed File]
                         Find Next Sequential record in Indexed File.
                 R3GET   250     [$GET/$FIND - Indexed File]
                         Get record in Indexed File.
                 R3GKEY  202     [Record I/O - Indexed File]
                         Get Key Descriptor from Indexed File Prologue.
                 R3GRPT  238     [$GET/$FIND - Indexed File]
                         Set  up  all Position Information for Indexed File
                         record.
                 R3GSET  100     [$GET/$FIND - Indexed File]
                         Validity  Check  prior  to  Get/Find  for  Indexed
                         Files.
                 R3GTRE  146     [$GET/$FIND - Indexed File]
                         Get  record  and  all  position  information  from
                         Indexed File.

         RMS-11 Internals                                              Page 81





                 R3IKEY  768     [$D/P/U - Indexed File]
                         Control  Module  for Index Bucket Insert/Split for
                         Indexed Files.
                 R3IKYI  248     [$D/P/U - Indexed File]
                         Insert Index Record into bucket for Indexed Files.
                 R3ISDI  434     [$D/P/U - Indexed File]
                         Insert SIDR Record into bucket for Indexed Files.
                 R3ISID  876     [$D/P/U - Indexed File]
                         Control  Module  for SIDR Insert/Split for Indexed
                         Files.
                 R3IUDC  732     [$D/P/U - Indexed File]
                         Calculate  UDR Insert/Split parameters for Indexed
                         Files.
                 R3IUDI  538     [$D/P/U - Indexed File]
                         Insert  UDR  into non-splitting bucket for Indexed
                         Files.
                 R3IUDR  882     [$D/P/U - Indexed File]
                         Control  Module  to Build/Insert new UDR in bucket
                         for Indexed Files.
                 R3KREF  36      [Record I/O - Indexed File]
                         Set  up  Key-of-Reference in RAB Temps for Indexed
                         Files.
                 R3KSPL  798     [$D/P/U - Indexed File]
                         Index  Bucket Split Processing Routine for Indexed
                         Files.
                 R3MISC  72      [Record I/O - Indexed File]
                         Spread  Data  in Bucket for new insert for Indexed
                         Files.    Move  High-key from Split bucket to IRAB
                         Key buffer for Indexed Files.
                 R3MKID  818     [$D/P/U - Indexed File]
                         Allocate  & Format Root & Data Buckets for Indexed
                         Files.
                 R3NBKT  58      [Record I/O - Indexed File]
                         Get Next Indexed File Bucket in horizontal chain.
                 R3OPFL  74      [Indexed File]
                         Open Module for Indexed Files.
                 R3PIXC  190     [$D/P/U - Indexed File]
                         Clean   up  buckets  after  Put/Update  error  for
                         Indexed Files.
                 R3POSE  88      [$GET/$FIND - Indexed File]
                         Position  to  Next  Sequential  record  in indexed
                         file.
                 R3POSR  1154    [$GET/$FIND - Indexed File]
                         Position to Requested Record in Indexed File.
                 R3PSET  280     [$PUT - Indexed File]
                         Set  Up/Validity Checking prior to Put for Indexed
                         Files.
                 R3PUT   668     [$PUT - Indexed File]
                         Put Record Control Module for Indexed Files.
                 R3ROOT  396     [$D/P/U - Indexed File]
                         Split Root of an Index.
                 R3RPLC  142     [$DELETE/$UPDATE - Indexed File]
                         Check  for  Indexed  File Record Pointer locked by
                         stream.

         RMS-11 Internals                                              Page 82





                 R3RPLG  370     [Indexed File]
                         Read Indexed File Prologue.
                 R3SDBK  460     [Record I/O - Indexed File]
                         Search Indexed File bucket for particular record.
                 R3SKDL  256     [$DELETE/$UPDATE - Indexed File]
                         SIDR Key Delete Routine for Indexed Files.
                 R3SKRE  136     [$D/P/U - Indexed File]
                         Skip over record in Data Bucket for Indexed Files.
                 R3SRRV  14      [-]
                         Dummy Module.
                 R3SSPL  288     [$D/P/U - Indexed File]
                         SIDR Bucket Split Routine for Indexed Files.
                 R3UIDX  174     [$D/P/U - Indexed File]
                         Update Indexed File Index for new key.
                 R3UPDA  886     [$UPDATE/$DELETE - Indexed File]
                         Update Record control Module for Indexed Files.
                 R3URRV  354     [$D/P/U - Indexed File]
                         Update all RRVs after UDR Bucket Split for Indexed
                         Files.
                 R3USET  206     [$UPDATE/$DELETE - Indexed File]
                         Set  Up/Validity  Checking  prior  to  Update  for
                         Indexed Files.
                 R3WBKT  116     [Record I/O - Indexed File]
                         Wait for Locked Indexed File Bucket.
                 R3WPLG  1882    [$CREATE - Indexed File]
                         Create prologue for Indexed Files.
                 SAVRG   20      [All]
                         Same as SYSLIB routine but in different PSECT.

                 Note  that  the  RMS  routines  in SYSLIB (RMSFUN.OBJ) are
                 exact  copies  of  the User-RMS Interface Modules (R0CLOS,
                 R0CONN,  R0CREA,  R0DELE,  R0DISC, R0DISP, R0ERAS, R0EXTE,
                 R0FBDB,  R0FIND,  R0GET,  R0INIT,  R0OPEN,  R0PUT, R0REWI,
                 R0RWBL,  R0TRUN,  R0UPDA  &  R0WAIT) plus the ORG-specific
                 file  function  dispatch  module  (R0IFLF).  I do not know
                 what purpose they serve there.


         RMS-11 Internals                                              Page 83





                 It  is also occasionally useful for the user designing his
                 own  overlays  to  know  what calls what.  The danger with
                 RMS-11  is  that  some  routines are called indirectly via
                 transfer  vectors  held  in  the  Impure  Area in the root
                 segment.    These  are  the  ones  in  the following table
                 referenced by .MAIN.  In general the following list should
                 only  really  be  used  with  the above list and the RMS11
                 overlay  to  see  why  various are required even when they
                 don't seem relevant to the matter at hand.

         Symbol    Defined in    Referenced By
         ======    ==========    =============

         BLKIO     R0RWBI
         $ALBDB    R0ALBD     R0ALDB  R0EXT0  R1CONP  R2CONP  R2WPLG
                              R3CONP  R3WPLG
         $ALBST    R0ALBS     R1CONP  R2CONP  R3CONP
         $ALBUF    R0ACBB     R0ALIO
         $ALCBL    R0ACBB     R0ALBD  R0RSES  R3RPLG  R3WPLG
         $ALDBF    R0ALDB     R0ALBS  R0DPYC  R0EXT0  R0MKWA
         $ALIOB    R0ALIO     R0ALDB
         $ALKYB    R0ACBB     R3CONP
         $ALLBF    R0ACBB     R0ALIO
         $ALNCB    R0ACBB
         $ALOC     R3ALOC     R3IKEY  R3ISID  R3IUDR  R3MKID
         $ASLN1    R0ASLN     R0PRFN
         $ASLUN    R0ASLN     R0PRFN
         $BFMT     R3BFMT     R3IKEY  R3ISID  R3IUDR  R3MKID
         $BFMT2    R2BFMT     R0EXT0  R2EXTD  R2WPLG
         $BKAL     R3ALOC     R3IKEY  R3ISID  R3IUDR  R3MKID
         $BKTSZ    R3IKEY
         $BKWRT    R3ISID
         $BLDCR    R3ISID     R3ISDI  R3SSPL
         $BLDNW    R3ISID     R3ISDI  R3SSPL
         $BLUDR    R3IUDR     R3BSPL
         $BRRV     R3BRRV     R3IUDR
         $BSPL     R3BSPL     R3IUDR
         $BSRT     R3BSRT     R3ISDI  R3IUDI
         $CACH     R0CACH     R0CCLN  R0DPYC  R0EXT0  R0GETB  R0RWBI
                              R1NXBK  R2BFMT  R2IOCK  R2OPFL  R2WPLG
                              R3ALOC  R3CONP  R3DISC  R3GKEY  R3RPLG
                              R3WPLG
         $CAHLK    R0CACH     R0CCLN  R0FREE  R0RWBI  R1OPFL  R2CONP
                              R2FIND  R2GET   R3CONP  R3DISC  R3DLSI
                              R3FIND  R3FRKE  R3FRRF  R3GET   R3POSR
         $CALC2    R2CALC     R2FIND
         $CALRP    R3ISDI
         $CCLNU    R0CCLN     R1CONP  R2CONP  R3CONP
         $CCLN1    R0CCLN     R1CONP  R2CONP  R3CONP
         $CCLN2    R0CCLN     R1CONP
         $CCOM0    R3CONP
         $CHKAL    R0CACH     R0DPYC  R0EXT0  R1CLOS  R2CLOS  R3CLOS
         $CKEF1    R1CKEF     R1GBLD  R1PUT
         $CKMAS    R3FNDR     R3PUT

         RMS-11 Internals                                              Page 84





         $CKMS1    R3FNDR     R3IKEY  R3IUDR  R3PUT
         $CKPAC    R0CMKY     R3FRKE
         $CKPC1    R0CMKY
         $CKSUM    R0CKSM     R0DPYC  R0EXT0  R2IOCK  R2OPFL  R3ALOC
                              R3GKEY  R3RPLG
         $CLOTV    R0IMPA     R0CLOS
         $CLO1E    R1CLOS     .MAIN.
         $CLO2E    R2CLOS     .MAIN.
         $CLO3E    R3CLOS     .MAIN.
         $CLO4E    R3CLOS
         $CLSCU    R0CLCM     R0IFLF  R1CLOS  R2CLOS  R3CLOS
         $CLTFN    R0GCML
         $CMKYN    R0CMKY     R3PIXC  R3PUT   R3SKDL  R3UPDA
         $CMKY0    R0CMKY     R3POSR  R3SDBK
         $CMKY1    R0CMKY     R3SDBK
         $CMKY2    R0CMKY     R3PSET  R3SDBK
         $CMKY3    R0CMKY     R3SDBK  R3UPDA
         $CONTV    R0IMPA     R0CONN
         $CON1E    R1CONP     .MAIN.
         $CON2E    R2CONP     .MAIN.
         $CON3E    R3CONP     .MAIN.
         $CPOOL    R0ACBB     R0RTCB
         $CRCK1    R1CRCK     R1CRFL
         $CRCK2    R2CRCK     R2CRFL
         $CRCK3    R3CRCK     R3CRFL
         $CRECM    R0CRFL     R1CRFL  R2CRFL  R3CRFL
         $CRETV    R0IMPA     R0CREA
         $CRE1E    R1CRFL     .MAIN.
         $CRE2E    R2CRFL     .MAIN.
         $CRE3E    R3CRFL     .MAIN.
         $CRXIT    R0CRXI     R1CRFL  R2CRFL  R3CRFL
         $DCCOM    R0CCLN     R3DISC
         $DCOM     R0CCLN     R1DISC  R2DISC
         $DDIV     DARITH     R0RECN  R2CALC
         $DELTV    R0IMPA     R0DELE
         $DEL1E    R1DELE     .MAIN.
         $DEL2E    R2DELE     .MAIN.
         $DEL3E    R3DELE     .MAIN.
         $DEV      R0MFNB
         $DISTV    R0IMPA     R0DISC
         $DIS1E    R1DISC     .MAIN.
         $DIS2E    R2DISC     .MAIN.
         $DIS3E    R3DISC     .MAIN.
         $DIS4E    R3DISC
         $DIV      ARITH      R1PBLD
         $DLSID    R3DLSI     R3PIXC  R3SKDL
         $DMUL     DARITH     R0DPYC  R0RECN  R2CALC
         $DPYCM    R0DPYC     R0DISP  R0OPEN
         $DSET     R3DSET     R3DELE
         $ERA0E    R0ERFL     R0ERAS
         $EXFIL    R0EXSY     R0IMPA
                   R0EXEC
         $EXGSG    R0EXSY     R0IMPA
                   R0EXEC

         RMS-11 Internals                                              Page 85





         $EXREA    R0EXSY     R0IMPA
                   R0EXEC
         $EXSPF    R0EXSY     R0IMPA
                   R0EXEC
         $EXTD     R0EXTD     R0EXT0  R1RLBK  R2EXTD  R3ALOC  R3WPLG
         $EXTD2    R2EXTD     R2IOCK
         $EXTHS    R0EXSY     R0IMPA
                   R0EXEC
         $EXT0E    R0EXT0     R0EXTE
         $EXWAI    R0EXSY     R0IMPA
                   R0EXEC
         $EXWRI    R0EXSY     R0IMPA
                   R0EXEC
         $FDSET    R3GSET     R3FIND
         $FIND2    R2FIND     R2GET   R2PUT
         $FINTV    R0IMPA     R0FIND
         $FIN1E    R1GET      .MAIN.
         $FIN2E    R2FIND     .MAIN.
         $FIN3E    R3FIND     .MAIN.
         $FLU0E    R0FREE     R0FBDB
         $FLU0I    R0FREE
         $FNAM     R0MFNB     R0CRFL  R0ERFL  R0OPFL
         $FNDRC    R3FNDR     R3DLSI  R3FPAT  R3FRKE  R3POSR  R3PUT
                              R3UIDX  R3UPDA
         $FPATH    R3FPAT     R3PUT   R3UPDA
         $FRE0E    R0FREE     R0FBDB
         $FRE0I    R0FREE     R0MAGT  R0RWIN
         $FRFA     R3FRFA     R3DELE  R3FRRV  R3POSR  R3URRV
         $FRKEY    R3FRKE     R3FIND  R3GET
         $FROOT    R3FROO     R3DLSI  R3FPAT  R3FRKE  R3POSR  R3UIDX
         $FRRFA    R3FRRF     R3FIND  R3GET
         $FRRV     R3FRRV     R3FRKE  R3FRRF  R3PIXC  R3POSR
         $FRSEQ    R3FRSE     R3FIND  R3GET
         $FSET     R0RSES     R0CLOS  R0DISP  R0EXTE
                   R0RSET
         $FSETI    R0RSES     R0CREA  R0ERAS  R0OPEN
                   R0RSET
         $FSET1    R1GSET     R1GET
         $FSET2    R2GSET     R2FIND
         $GBKTP    R0GPTR     R3FNDR
         $GBLDV    R1GBLD     R1GET
         $GETBK    R0GETB     R3BRRV  R3FNDR  R3FRFA  R3FROO  R3IKEY
                              R3ISID  R3IUDR  R3MKID  R3NBKT  R3SKDL
                              R3WBKT
         $GETTV    R0IMPA     R0GET
         $GET1E    R1GET      .MAIN.
         $GET2E    R2GET      .MAIN.
         $GET3E    R3GET      .MAIN.
         $GFCEX    R3GET      R3FIND
         $GKEYD    R3GKEY     R3FROO  R3MKID  R3ROOT
         $GRECP    R0GPTR
         $GRPTR    R3GRPT     R3FIND  R3GTRE
         $GSET     R3GSET     R3GET
         $GSET1    R1GSET     R1GET

         RMS-11 Internals                                              Page 86





         $GSET2    R2GSET     R2GET
         $GTBK1    R1NXBK     R1GBLD  R1PBLD  R1PUNR  R1UBLD
         $GTREC    R3GTRE     R3GET
         $GUNRC    R1GBLD     R1GET
         $G2ERX    R2GET      R2FIND
         $IDPB     R0IDPB     R0CRFL  R0DPYC  R0EXTD  R0MAGT  R0RWBF
                              R0RXAC  R0RXCR  R0RXDI  R0RXMD  R0UNLK
                              R0WATR
         $IFLCU    R0IFLF     R0CREA  R0ERAS  R0OPEN
         $IFLFN    R0IFLF     R0CREA  R0ERAS  R0OPEN
         $IKEY     R3IKEY     R3UIDX
         $IKYI     R3IKYI     R3IKEY
         $ISDI     R3ISDI     R3ISID
         $ISID     R3ISID     R3PUT   R3UPDA
         $IUDC     R3IUDC     R3IUDR
         $IUDI     R3IUDI     R3IUDR
         $IUDR     R3IUDR     R3PUT   R3UPDA
         $IXBK1    R3IKEY     R3IKYI  R3KSPL
         $IXBK3    R3IKEY     R3IKYI  R3KSPL
         $IXORG    R3IKEY     R3IKYI  R3KSPL
         $KREF     R3KREF     R3DELE  R3FRKE  R3FRRF  R3FRRV  R3FRSE
                              R3PIXC  R3POSE  R3PSET  R3PUT   R3RPLC
                              R3SKDL  R3UPDA  R3USET
         $KSPL     R3KSPL     R3IKEY
         $LSTAL    R0RWBF     R2IOCK  R3ALOC  R3DLSI  R3FPAT  R3GET
                              R3GKEY  R3RPLG  R3URRV  R3WBKT
         $MAP0     R0MAPC     R0DPYC  R0EXT0  R0GETB  R0MKWA  R0RLSB
                              R0RWBF  R1CLOS  R1NXBK  R1PUNR  R2DELE
                              R2EXTD  R2FIND  R2GET   R2IOCK  R2OPFL
                              R2PUT   R2UPDA  R2WPLG  R3DELE  R3FNDR
                              R3FRFA  R3FRKE  R3FROO  R3FRRF  R3FRRV
                              R3GKEY  R3GTRE  R3IKEY  R3ISDI  R3IUDC
                              R3PIXC  R3POSR  R3ROOT  R3RPLC  R3RPLG
                              R3SKDL  R3UPDA  R3URRV  R3WPLG
         $MAP1     R0MAPC     R2BFMT  R3ALOC  R3BFMT  R3BRRV  R3IKEY
                              R3ISID  R3IUDR  R3MKID  R3NBKT  R3SSPL
                              R3URRV
         $MDATA    R0MDAT     R1GBLD  R1PBLD  R1PUNR  R1UBLD  R2GET
                              R2PUT   R2UPDA  R3BRRV  R3BSPL  R3DLSI
                              R3GRPT  R3GTRE  R3IKEY  R3ISID  R3IUDC
                              R3IUDI  R3IUDR  R3KSPL  R3MISC  R3MKID
                              R3PIXC  R3ROOT  R3SSPL
         $MFNB     R0MFNB
         $MKIDX    R3MKID     R3PUT   R3UPDA
         $MKSUM    R0CKSM     R0EXT0  R2EXTD  R2WPLG  R3ALOC  R3MKID
                              R3ROOT  R3WPLG
         $MKWA     R0MKWA     R0PRFN
         $MPBK1    R1NXBK     R1GBLD  R1PBLD  R1PUNR  R1UBLD  R1WTLS
         $MUL      ARITH
         $MVKEY    R3MISC     R3FPAT  R3GRPT  R3IKEY  R3ISID  R3IUDC
                              R3PSET  R3SKDL
         $NBKT     R3NBKT     R3FNDR
         $NBKT1    R3NBKT     R3FNDR
         $NXBK1    R1NXBK     R1GBLD  R1PBLD  R1UBLD

         RMS-11 Internals                                              Page 87





         $NXBK2    R1NXBK     R1GBLD
         $NXT0E    R0MAGT     R0FBDB
         $OPETV    R0IMPA     R0OPEN
         $OPE1E    R1OPFL     .MAIN.
         $OPE2E    R2OPFL     .MAIN.
         $OPE3E    R3OPFL     .MAIN.
         $OPNCM    R0OPFL     R0OPEN
         $PBLDV    R1PBLD     R1PUT
         $PIXCL    R3PIXC     R3PUT
         $POSEQ    R3POSE     R3GET
         $POSRE    R3POSR     R3FRSE  R3POSE
         $PRFN     R0PRFN     R0ERAS  R0OPEN
         $PRFNC    R0PRFN     R0CREA
         $PSET     R3PSET     R3PUT
         $PSET1    R1PSET     R1PUT   R1UPDA
         $PSET2    R2PSET     R2PUT
         $PUNRC    R1PUNR     R1PUT
         $PUTTV    R0IMPA     R0PUT
         $PUT1E    R1PUT      .MAIN.
         $PUT2E    R2PUT      .MAIN.
         $PUT3E    R3PUT      .MAIN.
         $RDAH     R0RWBF     R0CACH
         $RDBFW    R0RWBF     R0CACH  R0RWBI
         $RDBK2    R2IOCK     R2EXTD  R2FIND
         $REA0E    R0RWBI     R0RWBL
         $RECSZ    R3ISID     R3ISDI  R3SSPL
         $REL0E    R0FREE     R0FBDB
         $RGCM1    R0GCML
         $RGCM2    R0GCML
         $RGCM3    R0GCML
         $RLBK1    R1RLBK     R1CLOS  R1NXBK  R1PBLD  R1UBLD  R1WTLS
         $RLBK2    R2IOCK     R2DELE  R2EXTD  R2FIND  R2PUT   R2UPDA
         $RLCB     RQLCB      R0RTCB
         $RLCH     R0RLCH     R0CCLN  R0CLCM  R0CRXI  R0DPYC  R0EXT0
                              R0FREE  R0RLSB  R0RWBI  R1RLBK  R2BFMT
                              R2IOCK  R2WPLG  R3ALOC  R3CONP  R3DISC
                              R3FROO  R3GKEY  R3IKEY  R3ISID  R3MKID
                              R3PUT   R3ROOT  R3RPLG  R3UIDX  R3UPDA
                              R3URRV  R3WPLG
         $RLNER    R0RLCH     R0CLCM  R0EXT0  R0FREE  R0GETB  R0RLSB
                              R0RWBI  R1GBLD  R1NXBK  R1RLBK  R1TRUN
                              R2IOCK  R2OPFL  R2WPLG  R3ALOC  R3FROO
                              R3FRRV  R3GKEY  R3IUDR  R3MKID  R3ROOT
                              R3RPLG  R3WPLG
         $RLSBK    R0RLSB     R3DELE  R3DLSI  R3FIND  R3FNDR  R3FPAT
                              R3FRKE  R3FROO  R3FRRF  R3FRRV  R3GET
                              R3GTRE  R3IKEY  R3ISID  R3IUDR  R3MKID
                              R3PIXC  R3POSR  R3PUT   R3ROOT  R3SKDL
                              R3UIDX  R3UPDA  R3URRV  R3WBKT
         $RMCLO    R0CLOS     R0GCML  .MAIN.
         $RMCON    R0CONN     R0GCML  .MAIN.
         $RMCRE    R0CREA     .MAIN.
         $RMDEL    R0DELE     .MAIN.
         $RMDIS    R0DISC     .MAIN.

         RMS-11 Internals                                              Page 88





         $RMDSP    R0DISP     .MAIN.
         $RMERA    R0ERAS     .MAIN.
         $RMEXT    R0EXTE     .MAIN.
         $RMFIN    R0FIND     R0GCML  .MAIN.
         $RMFLU    R0FBDB     .MAIN.
         $RMFRE    R0FBDB     .MAIN.
         $RMGET    R0GET      R0GCML  .MAIN.
         $RMINF    R0INIT     R0GCML  .MAIN.
         $RMNXT    R0FBDB     .MAIN.
         $RMOPE    R0OPEN     R0GCML  .MAIN.
         $RMPUT    R0PUT      R0GCML  .MAIN.
         $RMREA    R0RWBL     .MAIN.
         $RMREC    R0RECN
         $RMREL    R0FBDB
         $RMRWI    R0REWI     .MAIN.
         $RMSAB    R0RMSA     R0CACH  R0DPYC  R0EXT0  R0GETB  R0RLCH
                              R0RLSB  R0RSES  R0WAIT  R1CLOS  R1NXBK
                              R1PUNR  R2BFMT  R2DELE  R2EXTD  R2FIND
                              R2GET   R2IOCK  R2OPFL  R2PUT   R2UPDA
                              R2WPLG  R3ALOC  R3BFMT  R3BRRV  R3DELE
                              R3FNDR  R3FPAT  R3FRFA  R3FRKE  R3FROO
                              R3FRRF  R3FRRV  R3GKEY  R3GTRE  R3IKEY
                              R3ISID  R3IUDC  R3IUDR  R3MKID  R3NBKT
                              R3PIXC  R3POSE  R3POSR  R3ROOT  R3RPLG
                              R3SDBK  R3SKDL  R3SSPL  R3UPDA  R3URRV
                              R3WPLG
         $RMSEX    R0RMSE     R0CREA  R0DISP  R0EXSY  R0EXT0  R0FREE
                              R0MAGT  R0OPEN  R0RWBI  R0RWIN  R1CLOS
                              R1CONP  R1DELE  R1GET   R1PUT   R1TRUN
                              R1UPDA  R2CLOS  R2CONP  R2DELE  R2FIND
                              R2GET   R2PUT   R2UPDA  R3CLOS  R3CONP
                              R3DELE  R3FIND  R3GET   R3PUT   R3UPDA
         $RMSIA    R0IMPA     R0INIT  .MAIN.
         $RMSIN    R0INIT     .MAIN.
         $RMSPA    R0FBDB     .MAIN.
         $RMSX1    R0RMSE     R0CCLN  R0CLCM
         $RMSX2    R0RMSE     R0RSES
         $RMS10    R0IMPA     R0INIT
         $RMS12    R0IMPA     R0INIT
         $RMS14    R0IMPA     R0INIT
         $RMS16    R0IMPA     R0INIT
         $RMS18    R0IMPA     R0INIT
         $RMTRU    R0TRUN     .MAIN.
         $RMUPD    R0UPDA     .MAIN.
         $RMWAI    R0WAIT     .MAIN.
         $RMWRI    R0RWBL     .MAIN.
         $ROOT     R3ROOT     R3IKEY
         $RPCK     R3IKEY     R3IKYI  R3ROOT
         $RPLCK    R3RPLC     R3DSET  R3USET
         $RPLOG    R3RPLG     R3OPFL
         $RQCB     RQLCB      R0ACBB
         $RSET     R0RSES     R0DELE  R0DISC  R0FBDB  R0FIND  R0GET
                              R0PUT   R0REWI  R0RWBL  R0TRUN  R0UPDA
                   R0RSET

         RMS-11 Internals                                              Page 89





         $RSETI    R0RSES     R0CONN
                   R0RSET
         $RTBF1    R0RTCB
         $RTBUF    R0RTCB     R0RTDB
         $RTCBL    R0RTCB     R0CCLN  R0CLCM  R0RTDB  R1CLOS  R2CLOS
                              R3CLOS  R3CRFL  R3OPFL
         $RTDBF    R0RTDB     R0ALDB  R0EXT0  R0RLCH  R1OPFL  R2OPFL
                              R3OPFL
         $RTKYB    R0RTCB     R3CLOS  R3CONP  R3DISC
         $RTNCB    R0RTCB
         $RWI0E    R0RWIN     R0REWI
         $RWMT     R0MAGT     R0RWIN
         $RXACC    R0RXAC     R0CRFL  R0OPFL
         $RXCLO    R0RXAC     R0CLCM
         $RXCRE    R0RXCR     R0CRFL
         $RXDID    R0RXDI     R0CRFL  R0ERFL  R0OPFL
         $RXENT    R0RXDI     R0CRFL  R0ERFL
         $RXFND    R0RXDI     R0OPFL
         $RXMKD    R0RXMD     R0CRFL  R0ERFL
         $RXRMV    R0RXDI     R0CRFL  R0ERFL
         $SAVRG    SAVRG      RQLCB   R3SRRV  R3WPLG
         $SCPAC    R0CMKY     R3PSET  R3USET
         $SDBK     R3SDBK     R3FNDR  R3FRFA  R3POSR  R3URRV
         $SGR50    R0RD50     R0MFNB  R0RXDI
         $SKDLT    R3SKDL     R3DELE  R3UPDA
         $SKREC    R3SKRE     R3DLSI  R3FRKE  R3ISID  R3PIXC  R3POSR
                              R3PUT   R3RPLC  R3UPDA
         $SPA0E    R0MAGT     R0FBDB
         $SPMT     R0MAGT     R1TRUN
         $SPRED    R3MISC     R3IKYI  R3ISID  R3IUDI  R3IUDR  R3KSPL
         $SRRV     R3SRRV
         $SSPL     R3SSPL     R3ISID
         $SVFRQ    R0RXAC     R2OPFL  R3OPFL
         $TRU1E    R1TRUN     R0TRUN
         $UBLDV    R1UBLD     R1UPDA
         $UIDX     R3UIDX     R3PUT   R3UPDA
         $UNLK     R0UNLK     R0RLCH
         $UPDTV    R0IMPA     R0UPDA
         $UPD1E    R1UPDA     .MAIN.
         $UPD2E    R2UPDA     .MAIN.
         $UPD3E    R3UPDA     .MAIN.
         $URRV     R3URRV     R3IUDR
         $USET2    R2PSET     R2UPDA
         $USET3    R3USET     R3UPDA
         $WATBD    R0WTBS     R0CACH  R2IOCK  R2OPFL  R3ALOC  R3DLSI
                              R3GKEY  R3POSR  R3URRV  R3WBKT
                   R0WATB
         $WATDQ    R0WTBS     R0RWBF  R0UNLK
                   R0WATB
         $WATR     R0WATR     R0FREE  R0RWIN
         $WBKT     R3WBKT     R3FPAT  R3FRKE  R3POSR  R3UIDX
         $WPLG2    R2WPLG     R2CRFL
         $WPLOG    R3WPLG     R3CRFL
         $WRCK2    R2IOCK     R2EXTD  R2GET   R2PUT

         RMS-11 Internals                                              Page 90





         $WRI0E    R0RWBI     R0RWBL
         $WTBFW    R0RWBF     R0CACH  R0FREE  R0RLCH  R0RWBI  R1PUNR
                              R2BFMT
         $WTBH     R0RWBF     R0RLCH
         $WTLST    R1WTLS     R0FREE  R1DISC  R1GET
         $WUAB     R0EXTD
         $XPFN     R0XPFN     R0PRFN
         $$RMS1    R0IMPA
         $$RMS2    R0IMPA     R0INIT

                 In  general the references from .MAIN. listed above (apart
                 for  the  $RMxxx  ones)  are those that are defined in the
                 Transfer Vectors.

         RMS-11 Internals                                              Page 91





                                     _________                                     CHAPTER V

                             __________________________                             RMSBCK/RMSRST Tape Formats

                 There  is  virtually no documentation on the format of the
                 tape  created  by  RMSBCK  and  read by RMSRST.  Given the
                 reluctance  of  RMSRST at times to restore the contents of
                 such  a  tape, it might be useful to be able to circumvent
                 RMSRST.    The  following  is  a  short  discussion of the
                 important parts of the tape.

                 RMSBCK  will only write standard ANSI magtapes, and with a
                 blocking factor (that cannot be changed) of 2064 (decimal)
                 bytes  -  4  standard  FCS  blocks plus a 16 bytes header.
                 Thus  at  a  high level the tape is simply a standard ANSI
                 magtape  on  which  each  'file'  is  a container with the
                 attributes  of  Undefined  Record  Format,  Block & Record
                 Lengths of 2064 and Carriage Control type 'M'.

                 Within  the  container  the individual records are ordered
                 thus:-

                         Header for File 1
                         1st 4 blocks of File 1
                         2nd 4 blocks of File 1
                                 :
                         Last 4 (?) blocks of File 1
                         Header for File 2
                         1st 4 blocks of File 2
                                 :
                                 :
                 Each  record is 2064 bytes long, except possibly for those
                 holding  the  last few blocks of each file which will only
                 be as long as required to hold those blocks plus a 16 byte
                 header (i.e. 528, 1040 or 1552 bytes).

                 Every record (short or long, data or header) starts with a
                 16 byte header which is composed as follows:-

                 Bytes  0 -  1 Record Size in bytes (not counting header)
                 Bytes  2 -  3 Record Type (1 = Data, 2 = Header)
                 Bytes  4 -  7 Starting  Block  Number in File of Blocks in
                               Record (0 for Header records)
                 Bytes  8 - 11 Number of File in Container (1 -> n)
                 Bytes 12 - 15 Unused (?)


         RMS-11 Internals                                              Page 92





                 On the header records the remainder of the record contains
                 information  regarding the file (only some of which I have
                 managed to decode) as follows:-

                 Bytes   16 -   21   'BACKUP'
                 Bytes   22 -   25   Unknown
                 Byte    26          ':'
                 Bytes   27 -  109   File  Specification  in  ASCII (padded
                                     with nulls)
                 Bytes  110 -  141   User   File   Attributes   (from  File
                                     Header)
                 Bytes  142 -  175   Unknown
                 Bytes  176 - 2055   Zeroes
                 Bytes 2056 - 2061   'PUKCAB' (BACKUP backwards!)
                 Bytes 2062 - 2063   Checksum  of  words  from  16  to 2061
                                     (i.e. record minus header & checksum)

                 The  data  records,  after  the header, simply contain the
                 blocks of the file in order.
                 As  a  file  can be completely defined by its data blocks,
                 user  file  attributes and file specification it is fairly
                 easy to restore files from this format.

         RMS-11 Internals                                              Page 93





                                     __________                                     APPENDIX A

                           ______________________________                           Formatted Dump of Indexed File

                 This  appendix  contains  a  dump  of an Indexed File with
                 three  indices to demonstrate how all the theory discussed
                 earlier  really  looks in real-life.  The Indexed File was
                 created as follows:-

         SY:[1,12]EXAM.IDX;1     FILE ORGANIZATION:      INDEXED
         PROLOGUE VERSION NUMBER:        1
         CREATED: 28-AUG-1980 11:35
         FILE PROTECTION:        [RWED,RWED,RWED,R]
         RECORD FORMAT:          FIXED=35
         RECORD ATTRIBUTES:      CARRIAGE RETURN
         FILE ATTRIBUTES:
                 ALLOCATION= 311 EXTEND QUANTITY=0       BUCKET SIZE=7
         AREA NUMBER: 0
                 ALLOCATION REMAINING= 8
                 BUCKET SIZE=7   EXTEND QUANTITY=14

         AREA NUMBER: 1
                 ALLOCATION REMAINING= 0
                 BUCKET SIZE=3   EXTEND QUANTITY=6

         AREA NUMBER: 2
                 ALLOCATION REMAINING= 26
                 BUCKET SIZE=2   EXTEND QUANTITY=8


         PRIMARY KEY:    STRING
                 DUPLICATES      NO CHANGES
                 ROOT VIRTUAL BLOCK NUMBER=66    ROOT LEVEL=1
                 1ST DATA BUCKET VIRTUAL BLOCK NUMBER=6
                 KEY NAME:       OP CODE
                 POSITION:       2
                 SIZE:           3
                 TOTAL KEY SIZE=3        MINIMUM RECORD LENGTH=5
                 DATA LEVEL FILL SIZE=1200       INDEX LEVEL FILL SIZE=3000
                 DATA AREA=1     INDEX AREA=0

         ALTERNATE KEY:  1       STRING
                 DUPLICATES      CHANGEABLE
                 ROOT VIRTUAL BLOCK NUMBER=140   ROOT LEVEL=1
                 1ST DATA BUCKET VIRTUAL BLOCK NUMBER=11
                 KEY NAME:       FIRST CHARACTER
                 POSITION:       1
                 SIZE:           1
                 TOTAL KEY SIZE=1        MINIMUM RECORD LENGTH=2
                 DATA LEVEL FILL SIZE=770        INDEX LEVEL FILL SIZE=1340
                 DATA AREA=2     INDEX AREA=1    LOWEST LEVEL INDEX AREA=1


         RMS-11 Internals                                              Page 94





         ALTERNATE KEY:  2       STRING
                 NO DUPLICATES   NO CHANGES
                 ROOT VIRTUAL BLOCK NUMBER=172   ROOT LEVEL=1
                 1ST DATA BUCKET VIRTUAL BLOCK NUMBER=73
                 KEY NAME:       ODD RUBBISH
                 POSITION:       20
                 SIZE:           15
                 TOTAL KEY SIZE=15       MINIMUM RECORD LENGTH=35
                 DATA LEVEL FILL SIZE=3584       INDEX LEVEL FILL SIZE=800
                 DATA AREA=0     INDEX AREA=2    LOWEST LEVEL INDEX AREA=2


                 Several  records  were added to the file, and some deleted
                 just  to give it a relatively-average population.  It must
                 be  recalled,  of course, that the 'flexibility' of RMS-11
                 is  such  that this one example can only demonstrate a few
                 small aspects of Indexed File layouts.


         RMS-11 Internals                                              Page 95





        DUMP OF DP0:[1,12]EXAM.IDX;1 - FILE ID 411,120,0
                                                 FILE HEADER

        HEADER AREA
                 H.IDOF          027
                 H.MPOF          056
                 H.FNUM,
                 H.FSEQ          (411,120)
                 H.FLEV          401
                 H.FOWN          [001,012]
                 H.FPRO          [RWED,RWED,RWED,R]
                 H.UCHA          000 =
                 H.SCHA          000 =
                 H.UFAT
                         F.RTYP  041 = UNDEF = FB$IDX!FB$FIX
                         F.RATT  002 =   FD.CR
                         F.RSIZ  43 = 35.
                         F.HIBK  H:0 L:000467 = 311.
                         F.EFBK  H:0 L:000470 = 312.
                         F.FFBY  0 = 0.
                         (REST)
                         001007 000043 000000 000000 000000 000000 000000 000000
                         000000
        IDENTIFICATION AREA
                 I.FNAM,
                 I.FTYP,
                 I.FVER          EXAM     .IDX;1
                 I.RVNO          1
                 I.RVDT          28-AUG-80
                 I.RVTI          11:35:57
                 I.CRDT          28-AUG-80
                 I.CRTI          11:35:50
                 I.EXDT          --
        MAP AREA
                 M.ESQN          000
                 M.ERVN          000
                 M.EFNU,
                 M.EFSQ          (0,0)
                 M.CTSZ          001
                 M.LBSZ          003
                 M.USE           062 = 50.
                 M.MAX           314 = 204.
                 M.RTRV
                 SIZE    LBN
                 1.      H:000 L:011054 = 4652.
                 9.      H:000 L:011057 = 4655.
                 2.      H:000 L:024606 = 10630.
                 3.      H:000 L:033610 = 14216.
                         :
                         :
        CHECKSUM
                 H.CKSM          043310

         RMS-11 Internals                                              Page 96





        DUMP OF DP0:[1,12]EXAM.IDX;1 - FILE ID 411,120,0
                          VIRTUAL BLOCK 0,000001 - SIZE 512. BYTES
                          (Prologue Block 1)


        000000  002 000 000 000 000 000 000 000 001 001 007 003 102 000 000 000
                ! Next Key Descriptor  !IAN!LAN!DAN!LVL!IBK!DBK! VBN Root Bkt !
        000020  001 000 001 000 003 000 005 000 270 013 260 004 002 000 000 000
               !FLG!DTP!SEG!NUL!SIZ!KRF!Min Len!IDX Fil!DAT Fil! Key Segment
        000040  000 000 000 000 000 000 000 000 000 000 000 000 003 000 000 000
                Positions                                      ! Key Segment
        000060  000 000 000 000 117 120 040 103 117 104 105 000 000 000 000 000
                Sizes          !       Key Name
        000100  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000120  000 000 000 000 006 000 000 000 000 000 000 000 000 000 000 000
                               !1st Dat Bkt VBN!
        000140  000 000 000 000 000 000 003 003 000 000 000 000 000 000 000 000
                                      !AVBN!AMAX!
        000160  006 000 000 000 001 000 000 000 000 000 000 000 000 000 000 000
                               !PLG Ver!
        000200  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000220  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000240  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000260  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000300  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000320  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000340  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000360  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000400  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000420  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000440  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000460  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000500  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000520  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000540  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000560  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000600  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000620  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000640  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000660  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000700  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000720  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000740  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000760  000 000 000 000 000 000 000 000 000 000 000 000 000 000 326 357
                                                                       !Ck Sum!

         RMS-11 Internals                                              Page 97





        DUMP OF DP0:[1,12]EXAM.IDX;1 - FILE ID 411,120,0
                          VIRTUAL BLOCK 0,000002 - SIZE 512. BYTES
                         (Prologue Block 2)

        000000  002 000 000 000 146 000 001 001 002 001 003 002 214 000 000 000
                ! Next Key Descriptor  !IAN!LAN!DAN!LVL!IBK!DBK! VBN Root Bkt !
        000020  003 000 001 000 001 001 002 000 074 005 002 003 001 000 000 000
               !FLG!DTP!SEG!NUL!SIZ!KRF!Min Len!IDX Fil!DAT Fil! Key Segment
        000040  000 000 000 000 000 000 000 000 000 000 000 000 001 000 000 000
                Positions                                      ! Key Segment
        000060  000 000 000 000 106 111 122 123 124 040 103 110 101 122 101 103
                Sizes          !       Key Name
        000100  124 105 122 000 000 000 000 000 000 000 000 000 000 000 000 000
        000120  000 000 000 000 013 000 000 000 000 000 000 000 000 000 000 000
                               !1st Dat Bkt VBN!
        000140  000 000 000 000 000 000 000 000 000 000 000 000 002 002 000 001
                                       ! Next Key Descriptor  !IAN!LAN!DAN!LVL!
        000160  002 007 254 000 000 000 000 000 001 000 017 002 043 000 040 003
               !IBK!DBK! VBN Root Bkt  !FLG!DTP!SEG!NUL!SIZ!KRF!Min Len!IDX Fil!
        000200  000 016 024 000 000 000 000 000 000 000 000 000 000 000 000 000
               !DAT Fil! Key Segment Positions
        000220  000 000 017 000 000 000 000 000 000 000 117 104 104 040 122 125
                       ! Key Segment Sizes             !       Key Name
        000240  102 102 111 123 110 000 000 000 000 000 000 000 000 000 000 000
        000260  000 000 000 000 000 000 000 000 000 000 111 000 000 000 000 000
                                                       !1st Dat Bkt VBN!
        000300  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000320  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000340  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000360  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000400  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000420  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000440  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000460  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000500  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000520  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000540  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000560  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000600  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000620  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000640  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000660  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000700  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000720  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000740  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000760  000 000 000 000 000 000 000 000 000 000 000 000 000 000 312 134
                                                                       !Ck Sum!

         RMS-11 Internals                                              Page 98





        DUMP OF DP0:[1,12]EXAM.IDX;1 - FILE ID 411,120,0
                          VIRTUAL BLOCK 0,000003 - SIZE 512. BYTES
                          (Prologue Block 3)

        000000  000 000 000 007 000 000 000 000 000 000 000 000 102 000 000 000
               !   !FLG!AID!BKS!Rel Vol!AOP!ALN!1st Avail Bkt  !Cur Start VBN  !
        000020  062 000 000 000 052 000 000 000 154 000 000 000 000 000 000 000
               !Num Blks in Ext!Num Blks Used  !Next VBN to use!Nxt Ext Str VBN!
        000040  000 000 000 000 016 000 000 000 000 000 000 000 000 000 000 000
               !Blks in New Ext!Def Ext!       !Alloc Start Pt !Related File ID
        000060  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
                       !                                               ! Check !
        000100  000 000 001 003 000 000 000 000 000 000 000 000 062 001 000 000
               !   !FLG!AID!BKS!Rel Vol!AOP!ALN!1st Avail Bkt  !Cur Start VBN  !
        000120  006 000 000 000 006 000 000 000 070 001 000 000 000 000 000 000
               !Num Blks in Ext!Num Blks Used  !Next VBN to use!Nxt Ext Str VBN!
        000140  006 000 000 000 006 000 000 000 014 143 000 000 000 000 000 000
               !Blks in New Ext!Def Ext!       !Alloc Start Pt !Related File ID
        000160  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
                       !                                               ! Check !
        000200  000 000 002 002 000 000 000 000 000 000 000 000 246 000 000 000
               !   !FLG!AID!BKS!Rel Vol!AOP!ALN!1st Avail Bkt  !Cur Start VBN  !
        000220  062 000 000 000 030 000 000 000 276 000 000 000 000 000 000 000
               !Num Blks in Ext!Num Blks Used  !Next VBN to use!Nxt Ext Str VBN!
        000240  000 000 000 000 010 000 000 000 000 000 000 000 000 000 000 000
               !Blks in New Ext!Def Ext!       !Alloc Start Pt !Related File ID
        000260  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
                       !                                               ! Check !
        000300  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000320  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000340  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000360  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000400  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000420  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000440  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000460  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000500  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000520  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000540  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000560  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000600  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000620  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000640  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000660  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000700  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000720  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000740  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000760  000 000 000 000 000 000 000 000 000 000 000 000 000 000 137 164
                                                                       !Ck Sum !

         RMS-11 Internals                                              Page 99





        DUMP OF DP0:[1,12]EXAM.IDX;1 - FILE ID 411,120,0
                          VIRTUAL BLOCK 0,000102 - SIZE 512. BYTES
                          (Root Bucket - Primary Index)

        000000  040 000 102 000 050 001 001 377 102 000 000 000 001 003 000 006
               !Chk!Are!Adr Sam!Nxt Byt!NID!LID!VBN of Nxt Bkt !LVL!Ctl!!PS!Bkt
        000020  000 000 000 000 000 026 000 042 104 123 000 230 000 053 062 011
                Ptr!Key Val    !!PS!Bkt Ptr!Key Val    !!PS!Bkt Ptr! ...
        000040  000 031 000 061 051 040 000 236 000 101 114 114 000 037 000 101
        000060  116 113 000 021 001 101 123 103 000 371 000 101 123 113 000 363
        000100  000 101 126 114 000 360 000 101 154 154 000 042 000 103 102 104
        000120  000 336 000 104 104 011 000 050 000 105 116 101 000 225 000 105
        000140  123 072 000 053 000 106 103 102 000 377 000 110 111 123 000 241
        000160  000 111 104 105 000 222 000 111 106 040 000 061 000 111 156 164
        000200  000 065 001 114 111 123 000 062 001 114 113 104 000 341 000 114
        000220  122 102 000 067 000 115 101 130 000 233 000 115 120 011 000 352
        000240  000 116 105 011 000 072 000 117 114 072 000 366 000 117 126 011
        000260  000 172 000 120 101 107 000 330 000 120 104 103 000 016 001 120
        000300  120 103 000 013 001 120 124 103 000 005 001 120 124 117 000 175
        000320  000 122 103 072 000 374 000 122 114 125 000 347 000 122 125 072
        000340  000 200 000 123 102 124 000 333 000 123 122 011 000 040 001 123
        000360  124 011 000 032 001 123 124 101 000 203 000 124 105 123 000 024
        000400  001 124 111 124 000 217 000 125 102 011 000 206 000 126 103 104
        000420  000 344 000 126 125 116 000 355 000 130 111 124 000 054 001 150
        000440  141 156 000 211 000 377 377 377 000 000 000 000 000 000 000 000
                 ...    !PS!Bkt Ptr!Key Value  !
        000460  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000500  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000520  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000540  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000560  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000600  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000620  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000640  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000660  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000700  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000720  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000740  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000760  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000

         RMS-11 Internals                                              Page 100





        DUMP OF DP0:[1,12]EXAM.IDX;1 - FILE ID 411,120,0
                          VIRTUAL BLOCK 0,000006 - SIZE 512. BYTES
                          (Data Bucket - Primary Index)

        000000  017 001 006 000 366 005 045 377 020 000 000 000 000 000 002 001
               !Chk!Are!Adr Sam!Nxt Byt!NID!LID!VBN of Nxt Bkt !Lvl!Ctl!!PS!ID1!
        000020  001 006 000 000 000 073 000 000 000 000 000 000 000 000 000 000
               !ID2!Bucket Pointer !  Record ->
        000040  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000060  000 000 000 000 000 000 000 000 002 002 002 006 000 000 000 073
                                                !PS!ID1!ID2!Bucket Pointer !
        000100  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
                Record ...
        000120  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000140  000 000 002 003 003 006 000 000 000 073 000 000 000 000 000 000
        000160  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000200  000 000 000 000 000 000 000 000 000 000 000 000 006 004 004 006
        000220  000 000 000 073 000 000 000 000 000 000 000 000 000 000 000 000
        000240  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000260  000 000 000 000 000 000 006 005 005 006 000 000 000 073 000 000
        000300  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000320  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000340  006 006 006 006 000 000 000 073 000 000 000 000 000 000 000 000
        000360  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000400  000 000 000 000 000 000 000 000 000 000 006 007 007 006 000 000
        000420  000 073 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000440  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000460  000 000 000 000 006 010 010 006 000 000 000 073 000 000 000 000
        000500  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000520  000 000 000 000 000 000 000 000 000 000 000 000 000 000 002 011
        000540  011 006 000 000 000 073 000 000 000 000 000 000 000 000 000 000
        000560  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000600  000 000 000 000 000 000 000 000 002 012 012 006 000 000 000 073
        000620  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000640  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000660  000 000 002 013 013 006 000 000 000 073 000 000 000 000 000 000
        000700  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000720  000 000 000 000 000 000 000 000 000 000 000 000 002 014 014 006
        000740  000 000 000 073 000 000 000 000 000 000 000 000 000 000 000 000
        000760  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000

                 (Note Record 4 has been deleted - Offset 214)

         RMS-11 Internals                                              Page 101





        DUMP OF DP0:[1,12]EXAM.IDX;1 - FILE ID 411,120,0
                          VIRTUAL BLOCK 0,000007 - SIZE 512. BYTES


        000000  000 000 000 000 000 000 006 015 015 006 000 000 000 073 000 000
        000020  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000040  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000060  002 016 016 006 000 000 000 073 000 000 000 000 000 000 000 000
        000100  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000120  000 000 000 000 000 000 000 000 000 000 002 017 017 006 000 000
        000140  000 073 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000160  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000200  000 000 000 000 006 020 020 006 000 000 000 073 000 000 000 000
        000220  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000240  000 000 000 000 000 000 000 000 000 000 000 000 000 000 002 021
        000260  021 006 000 000 000 073 000 000 000 000 000 000 000 000 000 000
        000300  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000320  000 000 000 000 000 000 000 000 002 022 022 006 000 000 000 073
        000340  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000360  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000400  000 000 002 023 023 006 000 000 000 073 000 000 000 000 000 000
        000420  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000440  000 000 000 000 000 000 000 000 000 000 000 000 006 024 024 006
        000460  000 000 000 073 000 000 000 000 000 000 000 000 000 000 000 000
        000500  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000520  000 000 000 000 000 000 002 025 025 006 000 000 000 073 000 000
        000540  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000560  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000600  002 026 026 006 000 000 000 073 000 000 000 000 000 000 000 000
        000620  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000640  000 000 000 000 000 000 000 000 000 000 002 027 027 006 000 000
        000660  000 073 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000700  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000720  000 000 000 000 002 030 030 006 000 000 000 073 000 000 000 000
        000740  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000760  000 000 000 000 000 000 000 000 000 000 000 000 000 000 006 031

         RMS-11 Internals                                              Page 102





        DUMP OF DP0:[1,12]EXAM.IDX;1 - FILE ID 411,120,0
                          VIRTUAL BLOCK 0,000010 - SIZE 512. BYTES

        000000  031 006 000 000 000 073 000 000 000 000 000 000 000 000 000 000
        000020  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000040  000 000 000 000 000 000 000 000 006 032 032 006 000 000 000 073
        000060  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000100  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000120  000 000 002 033 033 006 000 000 000 073 000 000 000 000 000 000
        000140  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000160  000 000 000 000 000 000 000 000 000 000 000 000 002 034 034 006
        000200  000 000 000 073 000 000 000 000 000 000 000 000 000 000 000 000
        000220  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000240  000 000 000 000 000 000 002 035 035 006 000 000 000 073 000 000
        000260  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000300  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000320  006 036 036 006 000 000 000 073 000 000 000 000 000 000 000 000
        000340  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000360  000 000 000 000 000 000 000 000 000 000 006 037 037 006 000 000
        000400  000 073 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000420  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000440  000 000 000 000 006 040 040 006 000 000 000 073 000 000 000 000
        000460  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000500  000 000 000 000 000 000 000 000 000 000 000 000 000 000 002 041
        000520  041 006 000 000 000 073 000 000 000 000 000 000 000 000 000 000
        000540  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000560  000 000 000 000 000 000 000 000 002 042 042 006 000 000 000 073
        000600  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000620  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000640  000 000 002 043 043 006 000 000 000 073 000 000 000 000 000 000
        000660  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000700  000 000 000 000 000 000 000 000 000 000 000 000 006 044 044 006
        000720  000 000 000 073 000 000 000 000 000 000 000 000 000 000 000 000
        000740  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000760  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 017
                                                                           !Chk!

         RMS-11 Internals                                              Page 103





        DUMP OF DP0:[1,12]EXAM.IDX;1 - FILE ID 411,120,0
                          VIRTUAL BLOCK 0,000020 - SIZE 512. BYTES
                          (Continuation Data Bucket - Primary Index)

        000000  020 001 020 000 366 005 045 377 023 000 000 000 000 000 006 001
               !Chk!Are!Adr Sam!Nxt Byt!NID!LID!VBN of Nxt Bkt !LVL!Ctl!
        000020  001 020 000 000 000 073 000 000 000 000 000 000 000 000 000 000
        000040  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000060  000 000 000 000 000 000 000 000 002 002 002 020 000 000 000 073
        000100  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000120  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000140  000 000 002 003 003 020 000 000 000 073 000 000 000 000 000 000
        000160  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000200  000 000 000 000 000 000 000 000 000 000 000 000 002 004 004 020
        000220  000 000 000 073 000 000 000 000 000 000 000 000 000 000 000 000
        000240  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000260  000 000 000 000 000 000 006 005 005 020 000 000 000 073 000 000
        000300  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000320  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000340  006 006 006 020 000 000 000 073 000 000 000 000 000 000 000 000
        000360  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000400  000 000 000 000 000 000 000 000 000 000 002 007 007 020 000 000
        000420  000 073 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000440  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000460  000 000 000 000 006 010 010 020 000 000 000 073 000 000 000 000
        000500  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000520  000 000 000 000 000 000 000 000 000 000 000 000 000 000 002 011
        000540  011 020 000 000 000 073 000 000 000 000 000 000 000 000 000 000
        000560  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000600  000 000 000 000 000 000 000 000 002 012 012 020 000 000 000 073
        000620  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000640  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000660  000 000 002 013 013 020 000 000 000 073 000 000 000 000 000 000
        000700  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000720  000 000 000 000 000 000 000 000 000 000 000 000 002 014 014 020
        000740  000 000 000 073 000 000 000 000 000 000 000 000 000 000 000 000
        000760  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000

         RMS-11 Internals                                              Page 104





        DUMP OF DP0:[1,12]EXAM.IDX;1 - FILE ID 411,120,0
                          VIRTUAL BLOCK 0,000021 - SIZE 512. BYTES

        000000  000 000 000 000 000 000 006 015 015 020 000 000 000 073 000 000
        000020  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000040  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000060  002 016 016 020 000 000 000 073 000 000 000 000 000 000 000 000
        000100  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000120  000 000 000 000 000 000 000 000 000 000 006 017 017 020 000 000
        000140  000 073 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000160  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000200  000 000 000 000 002 020 020 020 000 000 000 073 000 000 000 000
        000220  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000240  000 000 000 000 000 000 000 000 000 000 000 000 000 000 002 021
        000260  021 020 000 000 000 073 000 000 000 000 000 000 000 000 000 000
        000300  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000320  000 000 000 000 000 000 000 000 006 022 022 020 000 000 000 073
        000340  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000360  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000400  000 000 002 023 023 020 000 000 000 073 000 000 000 000 000 000
        000420  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000440  000 000 000 000 000 000 000 000 000 000 000 000 006 024 024 020
        000460  000 000 000 073 000 000 000 000 000 000 000 000 000 000 000 000
        000500  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000520  000 000 000 000 000 000 006 025 025 020 000 000 000 073 000 000
        000540  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000560  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000600  002 026 026 020 000 000 000 073 000 000 000 000 000 000 000 000
        000620  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000640  000 000 000 000 000 000 000 000 000 000 002 027 027 020 000 000
        000660  000 073 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000700  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000720  000 000 000 000 002 030 030 020 000 000 000 073 000 000 000 000
        000740  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000760  000 000 000 000 000 000 000 000 000 000 000 000 000 000 006 031

         RMS-11 Internals                                              Page 105





        DUMP OF DP0:[1,12]EXAM.IDX;1 - FILE ID 411,120,0
                          VIRTUAL BLOCK 0,000022 - SIZE 512. BYTES

        000000  031 020 000 000 000 073 000 000 000 000 000 000 000 000 000 000
        000020  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000040  000 000 000 000 000 000 000 000 006 032 032 020 000 000 000 073
        000060  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000100  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000120  000 000 002 033 033 020 000 000 000 073 000 000 000 000 000 000
        000140  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000160  000 000 000 000 000 000 000 000 000 000 000 000 002 034 034 020
        000200  000 000 000 073 000 000 000 000 000 000 000 000 000 000 000 000
        000220  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000240  000 000 000 000 000 000 002 035 035 020 000 000 000 073 000 000
        000260  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000300  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000320  006 036 036 020 000 000 000 073 000 000 000 000 000 000 000 000
        000340  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000360  000 000 000 000 000 000 000 000 000 000 006 037 037 020 000 000
        000400  000 073 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000420  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000440  000 000 000 000 006 040 040 020 000 000 000 073 000 000 000 000
        000460  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000500  000 000 000 000 000 000 000 000 000 000 000 000 000 000 002 041
        000520  041 020 000 000 000 073 000 000 000 000 000 000 000 000 000 000
        000540  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000560  000 000 000 000 000 000 000 000 002 042 042 020 000 000 000 073
        000600  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000620  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000640  000 000 002 043 043 020 000 000 000 073 000 000 000 000 000 000
        000660  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000700  000 000 000 000 000 000 000 000 000 000 000 000 006 044 044 020
        000720  000 000 000 073 000 000 000 000 000 000 000 000 000 000 000 000
        000740  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000760  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 020
                                                                           !Chk!

         RMS-11 Internals                                              Page 106





        DUMP OF DP0:[1,12]EXAM.IDX;1 - FILE ID 411,120,0
                          VIRTUAL BLOCK 0,000023 - SIZE 512. BYTES
                          (Continuation Data Bucket - Primary Index)

        000000  347 001 023 000 314 005 217 377 026 000 000 000 000 000 002 001
               !Chk!Are!Adr Sam!Nxt Byt!NID!LID!VBN of Nxt Bkt !LVL!Ctl!
        000020  001 023 000 000 000 073 000 000 000 000 000 000 000 000 000 000
        000040  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000060  000 000 000 000 000 000 000 000 106 002 002 023 000 000 000 073
        000100  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000120  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000140  000 000 002 003 003 023 000 000 000 073 000 000 000 000 000 000
        000160  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000200  000 000 000 000 000 000 000 000 000 000 000 000 106 004 004 023
        000220  000 000 000 073 000 000 000 000 000 000 000 000 000 000 000 000
        000240  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000260  000 000 000 000 000 000 002 005 005 023 000 000 000 073 000 000
        000300  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000320  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000340  002 006 006 023 000 000 000 073 000 000 000 000 000 000 000 000
        000360  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000400  000 000 000 000 000 000 000 000 000 000 002 007 007 023 000 000
        000420  000 073 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000440  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000460  000 000 000 000 002 010 010 023 000 000 000 073 000 000 000 000
        000500  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000520  000 000 000 000 000 000 000 000 000 000 000 000 000 000 002 011
        000540  011 023 000 000 000 073 000 000 000 000 000 000 000 000 000 000
        000560  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000600  000 000 000 000 000 000 000 000 002 012 012 023 000 000 000 073
        000620  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000640  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000660  000 000 106 013 013 023 000 000 000 073 000 000 000 000 000 000
        000700  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000720  000 000 000 000 000 000 000 000 000 000 000 000 002 014 014 023
        000740  000 000 000 073 000 000 000 000 000 000 000 000 000 000 000 000
        000760  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000

         RMS-11 Internals                                              Page 107





        DUMP OF DP0:[1,12]EXAM.IDX;1 - FILE ID 411,120,0
                          VIRTUAL BLOCK 0,000024 - SIZE 512. BYTES

        000000  000 000 000 000 000 000 106 015 015 023 000 000 000 073 000 000
        000020  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000040  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000060  002 016 016 023 000 000 000 073 000 000 000 000 000 000 000 000
        000100  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000120  000 000 000 000 000 000 000 000 000 000 002 017 017 023 000 000
        000140  000 073 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000160  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000200  000 000 000 000 106 020 020 023 000 000 000 073 000 000 000 000
        000220  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000240  000 000 000 000 000 000 000 000 000 000 000 000 000 000 106 021
        000260  021 023 000 000 000 073 000 000 000 000 000 000 000 000 000 000
        000300  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000320  000 000 000 000 000 000 000 000 002 022 022 023 000 000 000 073
        000340  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000360  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000400  000 000 002 023 023 023 000 000 000 073 000 000 000 000 000 000
        000420  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000440  000 000 000 000 000 000 000 000 000 000 000 000 106 024 024 023
        000460  000 000 000 073 000 000 000 000 000 000 000 000 000 000 000 000
        000500  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000520  000 000 000 000 000 000 106 025 025 023 000 000 000 073 000 000
        000540  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000560  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000600  106 026 026 023 000 000 000 073 000 000 000 000 000 000 000 000
        000620  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000640  000 000 000 000 000 000 000 000 000 000 002 027 027 023 000 000
        000660  000 073 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000700  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000720  000 000 000 000 106 030 030 023 000 000 000 073 000 000 000 000
        000740  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000760  000 000 000 000 000 000 000 000 000 000 000 000 000 000 106 031

         RMS-11 Internals                                              Page 108





        DUMP OF DP0:[1,12]EXAM.IDX;1 - FILE ID 411,120,0
                          VIRTUAL BLOCK 0,000025 - SIZE 512. BYTES

        000000  031 023 000 000 000 073 000 000 000 000 000 000 000 000 000 000
        000020  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000040  000 000 000 000 000 000 000 000 106 032 032 023 000 000 000 073
        000060  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000100  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000120  000 000 106 033 033 023 000 000 000 073 000 000 000 000 000 000
        000140  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000160  000 000 000 000 000 000 000 000 000 000 000 000 106 034 034 023
        000200  000 000 000 073 000 000 000 000 000 000 000 000 000 000 000 000
        000220  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000240  000 000 000 000 000 000 002 035 035 023 000 000 000 073 000 000
        000260  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000300  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000320  002 036 036 023 000 000 000 073 000 000 000 000 000 000 000 000
        000340  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000360  000 000 000 000 000 000 000 000 000 000 002 037 037 023 000 000
        000400  000 073 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000420  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000440  000 000 000 000 106 040 040 023 000 000 000 073 000 000 000 000
        000460  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000500  000 000 000 000 000 000 000 000 000 000 000 000 000 000 002 041
        000520  041 023 000 000 000 073 000 000 000 000 000 000 000 000 000 000
        000540  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000560  000 000 000 000 000 000 000 000 002 042 042 023 000 000 000 073
        000600  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000620  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000640  000 000 106 043 043 023 000 000 000 073 000 000 000 000 000 000
        000660  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000700  000 000 000 000 000 000 000 000 000 000 000 000 002 216 216 023
        000720  000 000 000 073 000 000 000 000 000 000 000 000 000 000 000 000
        000740  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000760  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 347
                                                                           !Chk!

         RMS-11 Internals                                              Page 109





        DUMP OF DP0:[1,12]EXAM.IDX;1 - FILE ID 411,120,0
                          VIRTUAL BLOCK 0,000214 - SIZE 512. BYTES
                          (Root Bucket - Alternate Index 1)

        000000  011 001 214 000 072 000 001 377 214 000 000 000 001 003 000 013
               !Chk!Are!Adr Sam!Nxt Byt!NID!LID!VBN of Nxt Bkt !LVL!Ctl!!PS!Bkt
        000020  000 000 000 256 000 056 000 246 000 062 000 264 000 101 000 274
                Pkt!Key!!PS!Bkt Ptr!Key!!PS!Bkt Ptr!Key!!...
        000040  000 103 000 266 000 110 000 260 000 111 000 252 000 114 000 262
        000060  000 115 000 272 000 124 000 270 000 377 000 000 000 000 000 000
                                        !PS!Bkt Ptr!Key!
        000100  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000120  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000140  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000160  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000200  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000220  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000240  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000260  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000300  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000320  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000340  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000360  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000400  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000420  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000440  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000460  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000500  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000520  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000540  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000560  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000600  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000620  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000640  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000660  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000700  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000720  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000740  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000760  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000

         RMS-11 Internals                                              Page 110





        DUMP OF DP0:[1,12]EXAM.IDX;1 - FILE ID 411,120,0
                          VIRTUAL BLOCK 0,000013 - SIZE 512. BYTES
                          (Data Bucket - Alternate Index 1)

        000000  044 002 013 000 157 003 006 377 256 000 000 000 000 000 001 001
               !Chk!Are!Adr Sam!Nxt Byt!NID!LID!VBN of Nxt Bkt !LVL!Ctl!!PS!ID!
        000020  153 000 000 000 131 003 000 000 024 006 000 000 015 006 000 000
               !Duplicate Count! Size  !Key!SIDR Rec Ptr #1!SIDR Rec Ptr #2!...
        000040  007 020 000 000 020 023 000 000 033 006 000 000 022 023 000 000
        000060  040 006 000 000 035 023 000 000 041 020 000 000 032 006 000 000
        000100  021 023 000 000 013 023 000 000 021 006 000 000 024 020 000 000
        000120  036 006 000 000 042 023 000 000 011 023 000 000 036 020 000 000
        000140  043 020 000 000 004 020 000 000 033 023 000 000 031 020 000 000
        000160  004 023 000 000 043 023 000 000 017 023 000 000 026 023 000 000
        000200  033 020 000 000 021 020 000 000 034 023 000 000 011 006 000 000
        000220  006 006 000 000 030 020 000 000 026 020 000 000 002 006 000 000
        000240  022 020 000 000 010 006 000 000 041 006 000 000 016 006 000 000
        000260  012 023 000 000 022 006 000 000 030 006 000 000 003 006 000 000
        000300  011 020 000 000 042 006 000 000 012 006 000 000 001 020 000 000
        000320  003 020 000 000 026 006 000 000 044 020 000 000 037 020 000 000
        000340  020 006 000 000 032 023 000 000 007 006 000 000 015 020 000 000
        000360  007 023 000 000 030 023 000 000 014 020 000 000 013 020 000 000
        000400  042 020 000 000 036 023 000 000 001 023 000 000 002 020 000 000
        000420  044 006 000 000 040 020 000 000 023 020 000 000 015 023 000 000
        000440  006 023 000 000 023 006 000 000 012 020 000 000 031 006 000 000
        000460  010 023 000 000 040 023 000 000 005 020 000 000 034 020 000 000
        000500  027 020 000 000 027 006 000 000 024 023 000 000 010 020 000 000
        000520  034 006 000 000 037 006 000 000 032 020 000 000 037 023 000 000
        000540  002 023 000 000 017 006 000 000 017 020 000 000 023 023 000 000
        000560  035 020 000 000 025 020 000 000 014 023 000 000 027 023 000 000
        000600  005 023 000 000 020 020 000 000 041 023 000 000 003 023 000 000
        000620  025 023 000 000 006 020 000 000 016 020 000 000 016 023 000 000
        000640  031 023 000 000 005 006 000 000 001 006 000 000 043 006 000 000
        000660  004 006 000 000 035 006 000 000 013 006 000 000 025 006 000 000
        000700  014 006 000 004 044 023 000 004 045 023 000 004 046 023 000 004
        000720  047 023 000 004 050 023 000 004 051 023 000 004 052 023 000 004
        000740  053 023 000 004 054 023 000 004 055 023 000 004 056 023 000 004
        000760  057 023 000 004 060 023 000 004 061 023 000 004 062 023 000 004

                 (Note entries deleted - e.g. offset 706)

         RMS-11 Internals                                              Page 111





        DUMP OF DP0:[1,12]EXAM.IDX;1 - FILE ID 411,120,0
                          VIRTUAL BLOCK 0,000254 - SIZE 512. BYTES
                          (Root Bucket - Alternate Index 2)

        000000  005 002 254 000 150 000 001 377 254 000 000 000 001 003 000 111
               !Chk!Are!Adr Sam!Nxt Byt!NID!LID!VBN of Nxt Bkt !LVL!Ctl!!PS!Bkt
        000020  000 040 146 157 162 040 040 040 040 040 045 120 054 045 120 040
                Ptr!  Key Value                                                !
        000040  000 120 000 103 157 155 155 157 156 040 114 141 142 145 154 154
                !PS!Bkt Ptr!  Key Value
        000060  145 144 000 136 000 122 145 163 145 164 040 122 060 000 000 000
                       !!PS!Bkt Ptr!  Key Value ....
        000100  000 000 000 000 000 145 000 144 157 167 040 102 154 157 143 153
        000120  163 040 045 062 062 123 000 127 000 377 377 377 377 377 377 377
                                        !PS!Bkt Ptr!  Key Value
        000140  377 377 377 377 377 377 377 377 000 000 000 000 000 000 000 000
                                               !
        000160  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000200  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000220  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000240  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000260  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000300  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000320  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000340  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000360  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000400  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000420  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000440  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000460  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000500  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000520  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000540  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000560  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000600  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000620  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000640  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000660  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000700  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000720  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000740  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
        000760  000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000

         RMS-11 Internals                                              Page 112





        DUMP OF DP0:[1,12]EXAM.IDX;1 - FILE ID 411,120,0
                          VIRTUAL BLOCK 0,000111 - SIZE 512. BYTES
                          (Data Bucket - Alternate Index 2)

        000000  276 000 111 000 055 005 276 377 120 000 000 000 000 000 020 003
               !Chk!Are!Adr Sam!Nxt Byt!NID!LID!VBN of Nxt Bkt !LVL!Ctl!!PS!ID!
        000020  023 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000
               ! Size  !   Key Value
        000040  000 000 045 050 000 020 125 023 000 011 011 073 116 125 115 102
                   !SIDR Rec Ptr   !!PS!ID ! Size  !   Key Value
        000060  105 122 040 117 106 040 105 116 000 047 233 000 020 126 023 000
                                               !SIDR Rec Ptr   !!PS...
        000100  011 011 073 123 111 132 105 040 117 106 040 105 116 124 122 000
        000120  047 344 000 020 236 023 000 011 045 104 040 120 157 157 154 040
        000140  106 162 141 147 155 145 000 050 330 000 020 261 023 000 011 073
        000160  040 107 145 164 040 123 151 172 145 040 101 154 154 000 065 027
        000200  001 020 254 023 000 011 073 040 111 156 151 164 151 141 154 151
        000220  163 145 040 123 000 011 027 001 020 274 023 000 011 073 040 111
        000240  156 163 145 162 164 040 124 103 102 040 156 000 033 057 001 020
        000260  145 023 000 011 073 040 117 144 144 040 101 144 144 162 145 163
        000300  163 040 000 027 217 000 020 252 023 000 011 073 040 131 145 163
        000320  040 055 040 162 145 154 157 143 141 000 015 045 000 020 240 023
        000340  000 040 040 040 040 040 045 120 040 040 040 045 120 040 040 040
        000360  000 035 374 000 020 243 023 000 040 040 102 154 141 156 153 040
        000400  114 151 156 145 000 000 000 000 054 037 000 020 206 023 000 040
        000420  040 120 101 107 105 040 045 104 045 116 057 000 000 000 000 052
        000440  037 000 020 246 023 000 040 042 104 123 122 104 115 061 042 040
        000460  124 111 115 105 117 000 037 167 000 020 044 023 000 040 050 127
        000500  117 122 104 123 051 056 000 000 000 000 000 000 000 053 031 000
        000520  020 124 023 000 040 101 162 147 165 155 145 156 164 040 142 154
        000540  157 143 153 000 054 053 000 020 272 023 000 040 102 145 154 157
        000560  167 040 104 123 122 077 040 050 151 056 000 056 233 000 020 232
        000600  023 000 040 102 154 153 040 146 157 162 040 045 120 054 045 120
        000620  040 000 043 355 000 020 271 023 000 040 102 154 157 143 153 163
        000640  000 000 000 000 000 000 000 000 000 071 061 000 020 275 023 000
        000660  040 102 154 157 143 153 163 056 000 000 000 000 000 000 000 000
        000700  072 061 000 020 223 023 000 040 103 117 115 115 117 116 040 114
        000720  101 102 105 114 114 105 000 063 175 000 020 222 023 000 040 103
        000740  117 116 124 122 117 114 040 102 114 117 103 113 123 000 062 175
        000760  000 020 142 023 000 040 103 157 156 164 162 157 154 040 102 171

                 (Note PS field has bit set saying 'No Duplicate Count')

         RMS-11 Internals                                              Page 113





                                       __________                                       APPENDIX B

                       __________________________________________                       Some Additional RMS-11 Design/Logic Points

                 The   overall   design/structure   of  RMS-11  is  fairly  well
                 documented  in  RUG,  but a few points have come up either from
                 the  investigations  above  or  from  the RMS-11 Design & Logic
                 Manual which might be worth mentioning separately.  Those taken
                 from  the  manual  are  in general quoted verbatim and have not
                 been checked.

                 ___        a)       RFA

                 Curiously  enough  the  RFA  is never actually defined anywhere
                 (that  I could find).  However from the structure defined above
                 and a little experimentation it is fairly easy to deduce that:-

                         RFA Word 1 = 1st word of VBN of bucket holding RRV
                         RFA Word 2 = Record ID of RRV in bucket
                         RFA Word 3 = 2nd word of VBN of bucket holding RRV

                 It  is interesting to note that even using RFA access, RMS must
                 still  search  through the relevant bucket sequentially to find
                 the requested record.

                 _________        b)       Record ID

                 The  record ID is a fairly interesting field.  As seen above in
                 the  file  structures  it is only one byte long and hence has a
                 maximum  range of 0 - 255 (decimal).  Given that record IDs can
                 never  be  reused (or you would have a new record with the same
                 RFA  as  an old deleted one - which is illegal) this means that
                 during  its  ENTIRE  HISTORY  no  bucket may hold more than 255
                 records.    If the last ID is used, then as records are deleted
                 from a bucket more and more space is left unused!

                 It  is also interesting to note that it was originally intended
                 to  handle  this  problem.   The Design Manual entry on the LID
                 field in the Bucket Header states:-

                    "When the contents of B$NID are greater than the contents of
                    B$LID or is zero then there is no 'next' available ID.  When
                    this  condition  occurs  the  bucket  is scanned to find the
                    largest  contiguous  range of unused IDs and B$NID and B$LID
                    are  updated  to  describe  that  range.   This procedure is
                    deferred until we must do it (i.e. we wish to store a record
                    in  the bucket), and by updating B$NID and B$LID with the ID
                    of  a  record removed from the bucket when it is appropriate
                    to do so."



         RMS-11 Internals                                              Page 114





                 No  mention  is  made  of  how  the  RFA  problem would be
                 overcome by this method.  It is also interesting to note a
                 legacy  of  those ideas remains in the module R3BSRT which
                 currently contains only the code:-

                         CLR     10(R4)
                         SEC
                         RTS     PC

                 Even  when  believing such ID 'reuse' was possibly, it was
                 still  recognized  that  the method had limitations as the
                 RMS-11 Design & Logic Manual also states:-

                    "The  combination  of large buckets and a very volatile
                    file  (or one in which the records are inserted largely
                    in  inverse  order  of  Primary  Key value) can lead to
                    inefficient  space utilization: once RRVs (or vestigial
                    headers  from  deleted  records)  have  used up the 255
                    valid ID values in a bucket, any remaining space cannot
                    be  used  and  the  bucket  becomes static.  Occasional
                    rebuilding   of  such  highly  volatile  files  may  be
                    worthwhile  in some cases, but this will invalidate any
                    old RFA values which the user may have stored."

                 _____________________________         c)      VFC Print Control Information

                 The RMS-11 Design & Logic Manual mentions the concept of a
                 'two  byte print control field' in records with FB$PRN set
                 in  F$RATT  and  FB$VFC  in  F$FORG, even though it is not
                 currently supported by RMS or FCS.  The idea was:-

                    "Byte 0 is print control information to act upon before
                    the  record  data  is  output to a unit record device &
                    byte  1  is print control information to act upon after
                    the  record  data  has  been  output  to  a unit record
                    device.

                    The format of each byte is as follows:

                    Bit 7  Bits 6-0      Meaning

                    0      0             No carriage control
                    0      count (1-127) "count new lines" (CR/LF)

                    Bit 7  Bit 6  Bit 5  Bits 4-0      Meaning
                    1      0      0      ASCII C0 Set  ASCII Char to Output
                                                       (CR, FF, etc.)
                    1      0      1      ASCII C1 Set  ASCII  Char  (8  bit
                                                       code) to output
                    1      1      0      Code (0-63)   Device specific code
                    1      1      1      -             Reserved



         RMS-11 Internals                                              Page 115





                  ________________         d)      The 4th File Type

                 Every now and again reference is made in the RMS-11 Design
                 &  Logic  Manual  to  a  fourth  file  type, for which the
                 modules would be called R4xxxx and so on.  (Some vestigial
                 remains  exist  in  entry  points  such  as $CLO4E.)  When
                 referred to it is usually given the reference 'DIRECT' but
                 it is never mentioned what it was to have been.

                 _________________         e)      Bucket Splitting.

                 RUG  (5-17/18)  gives  a  detailed  breakdown  of  all the
                 overheads  of  Bucket  Splitting.    It  is possibly worth
                 quoting a comment in the RMS-11 Design & Logic Manual that
                 follows the (n**2+11n+20)/2 derivation:-

                    "For completeness, one should mention that there is one
                    slightly  worse  case  of  splitting.  When a record is
                    inserted  into  the  middle of a bucket, it is possible
                    that  it will be so large that it will fit neither with
                    the  set of records which have lower Primary Key values
                    nor  with the set which have higher Primary Key values.
                    In   this  case,  a  'three-bucket-split'  occurs:  the
                    lower-valued records remain in the original bucket, the
                    new   record   gets  a  bucket  of  its  own,  and  the
                    higher-valued  records  are placed in the third bucket;
                    the  Level 0 horizontal chain and the rest of the index
                    are  updated  accordingly.    One should realise that a
                    three-bucket split can occur only in the Primary Index,
                    and only at Level 0."


         RMS-11 Internals                                              Page 116





                 _______________________________         f)      RMS-11 Interlocking Algorithms.

                 This  is covered in two areas in the RMS-11 Design & Logic
                 Manual as follows:-

                    "One  might  reasonably  inquire why it is necessary to
                    return  to the Root of the index and work down for each
                    level  of index updating.  This is a consequence of the
                    fact  that  others  may be reading, or even writing to,
                    the   file  while  this  potentially  lengthy  updating
                    process is going on.  Some form of interlocking must be
                    employed   to   prevent   one  user  from  following  a
                    not-yet-updated  pointer  in  the index which no longer
                    correctly  represents  the just-updated bucket to which
                    it   points,   to   prevent   multiple   writers   from
                    simultaneously accessing the same bucket for update (if
                    this  were  allowed to happen, the update caused by the
                    first  writer  to  finish  would be over-written by the
                    second), etc.

                    RMS-11's 'top-down' approach guards against this in the
                    following  manner.  First, on every excursion downwards
                    through the index (for both read and write operations),
                    the  Root  bucket  is read and locked against access by
                    any  other  user.   The appropriate pointer is followed
                    down  to  the  next  index level, and the corresponding
                    bucket  at that level is read and locked.  Now the Root
                    bucket  is  released  and  the process is repeated: the
                    appropriate pointer is followed down another level, the
                    target   bucket   is   read   and   locked,   and   the
                    previously-locked  bucket  is  released (unlocked).  In
                    this  manner one proceeds down to the Data Level of the
                    index, finishing with only the target Data Level bucket
                    locked;  if at any point a non-Data Level target bucket
                    is  discovered  to  be  locked  by  someone  else,  the
                    existing  higher-level lock is released and RMS returns
                    to   the   Root  to  try  again,  since  the  algorithm
                    guarantees  that the other user's lock will be released
                    fairly soon.

                    This  completely  describes  interlocking on $GET/$FIND
                    operations.    On  write  operations,  the interlocking
                    process continues in a more involved manner:

                    Upon   reaching   the  Data  Level,  the  insertion  is
                    performed.    If  no  splits  occur  (and  there are no
                    Alternate  indexes)  the operation is complete, and the
                    Data  Level  bucket  is released.  Otherwise, a lock is
                    retained  on  the  Data Level bucket containing the new
                    (or  updated)  record  until all index updating is done
                    (including  Alternate Indexes, if any): this guarantees
                    that  no other user will be able to access the affected
                    record   in   any  manner  until  all  necessary  index
                    corrections have occurred.

         RMS-11 Internals                                              Page 117






                    Assuming  a  Data Level split has occurred, RMS returns
                    to the top of the index and steps down to Level 1 using
                    the  same  'lock next/unlock previous' method described
                    above.  Again, if any target bucket is discovered to be
                    locked  by someone else, RMS returns to the Root to try
                    again.    When Level 1 is reached, the target bucket is
                    updated;  at this point, only the Level 1 target bucket
                    and the Level 0 data bucket are still locked.

                    Should  a split occur in the Level 1 target bucket, the
                    lock on that bucket is retained while RMS again returns
                    to  the  Root  and  steps  down, as before, to Level 2.
                    Once  the  Level  2 target bucket has been successfully
                    locked,  the  Level  1 bucket is released (but the Data
                    Level  data bucket lock remains).  Should a split occur
                    on  Level 2, the Level 2 target bucket lock is retained
                    until  the  Level  3 bucket which points to it has been
                    successfully locked, and so on.

                    The consequences of this algorithm are the following:

                    1.  since  the  bucket  containing  the  data record is
                        locked  throughout  the  index  update(s),  no race
                        conditions   can  develop  wherein  a  second  user
                        modifies a record (and the resulting index entries)
                        before the original index entries have stabilized.

                    2.  any  second  user  stepping  down  through an index
                        which is being updated will encounter a lock on any
                        bucket  which  is  not  correctly  described by the
                        index  level  above it.  This second user must then
                        unlock  the  previous bucket and return to the Root
                        to  try  again.  Meanwhile, however, the task which
                        was  doing  the updating will also be attempting to
                        come  down  through  the index to update the bucket
                        which  the  second  user  has  just  released.  The
                        possibility  that  a second collision will occur at
                        this  bucket  is  very  slight,  and  dependent  on
                        timing;    in any case, no real deadlock can occur,
                        and the update will eventually succeed.

                    3.  there  is never any need to retain locks on any new
                        buckets  created by splitting above the Data Level,
                        since  the  algorithm  guarantees  that  there will
                        always  be  locks higher in the index which prevent
                        vertical  access  to  these  new  buckets until the
                        entire  index  has  been suitably modified.  In the
                        event  of  non-fatal  corruption  in the index, RMS
                        does   make  provision  for  using  the  horizontal
                        pointers  in  Level  1 and above to work around the
                        corrupted  area.    Even in this case, however, the
                        updating  of the level in question will be complete
                        before  access  can  occur  (due  to  locks at that
                        level),  and  since  all  lower levels have already
                        been appropriately modified the path downwards from
                        that point will be valid.

         RMS-11 Internals                                              Page 118






                    4.  the  maximum  number  of buckets which must ever be
                        simultaneously  locked  is 4: the bucket containing
                        the  actual  data record, the most recently updated
                        index  bucket, and the two locks which must be used
                        in  the  process of stepping down through the index
                        (this  will  later  be true for the Alternate index
                        updates  as  well).  On $GET/$FIND operations, only
                        the  two  'stepping  down'  locks  will  be needed.
                        Since  a  Buffer Descriptor Block (BDB) is required
                        for   each   simultaneously-locked   bucket,   this
                        establishes the minimum number of BDBs required for
                        read and read/write operations."

                 and:-

                    "Locking Modes.

                    When  a  file  is  opened, the locking mode of the file
                    will  be  determined from the user's file-access fields
                    (FAC,  SHR).  These modes determine how much locking is
                    necessary  for  future record operations.  The possible
                    locking modes are:-

                    1.  Exclusive access - no locking is done.
                    2.  Read-delete  access  - indices are not locked, data
                        records are locked.
                    3.  Write access - indices and data buckets are locked.

                    Note  that  the inclusion of $DELETE in mode #2 implies
                    that   all  deletions  are  'fast'  -  i.e.  no  bucket
                    compression is done.  This type of space reclamation is
                    done only when necessary during record insertions.


                    Horizontal Locking (Forward).

                    Forward  horizontal  index locking is done in a similar
                    manner  to  downwards locking.  If the target bucket is
                    already  locked,  backtracking  is necessary.  The task
                    must  release the current bucket and attempt to lock it
                    again.    When  this is done, the horizontal pointer is
                    fetched  again  and  a  second attempt to lock the next
                    bucket can be made.

                    Horizontal Locking (Backward).

                    Backward  horizontal locking is a potential in only one
                    situation: an RRV must be deleted or modified.  In this
                    case  the  'locker'  may  'block'  until  the  lock  is
                    granted.    This is because all forward locking is done
                    only  with  backtracking, so that deadly embrace is not
                    possible.    Since backward locking is done when bucket
                    compression  is  a  possibility,  it is advantageous to
                    give priority to such a process.


         RMS-11 Internals                                              Page 119





                    Secondary Index Locking.

                    Secondary  indices  are  generally  locked  in a manner
                    similar  to  primary  indices.  However, there are some
                    minor complications which are listed below:

                    1.  When  a  record  is  inserted, the primary index is
                        used  to determine the correct data bucket in which
                        it  should  go.   Next, the secondary index must be
                        traversed  in  order to find the correct index data
                        bucket  into which the new index data record should
                        go.   After insertion of the index data record, the
                        index  may  have to be locked from the top again if
                        bucket  splits occur.  Therefore, the worst case is
                        that  the index is locked all the way down for each
                        index level which splits.

                    2.  The  Data bucket remains locked during all updating
                        operations  on secondary indices.  Therefore, other
                        users  may  not  access  the  Data bucket until the
                        entire updating operation is completed.  This is to
                        avoid  the  situation where a secondary index has a
                        key value which is different from the corresponding
                        data record key value.

                    3.  During  secondary  index  updating,  each  index is
                        locked  in numerical order of key of reference, and
                        is   unlocked  immediately  after  modification  is
                        complete.    Since  RMS-11  will  not  support  the
                        combination  of  'no duplicates' and 'key value may
                        change'  attributes  on  secondary  keys,  updating
                        operations will not have to be 'unwound'.

                    4.  If  a data bucket split causes the target record to
                        be  moved  into the newly acquired bucket, then the
                        new  bucket  must  be  locked  also.    This is not
                        required  for  primary  index  operations  because,
                        since  the  index which points to the new bucket is
                        locked, no access to the bucket is possible.

                    Alternate Techniques

                    Another  scheme  for  locking  of  secondary indices is
                    still  under  consideration.    Instead  of locking the
                    index  on  each  level, this alternative would lock the
                    entire  index  whenever  a modification to it was to be
                    done.   Because the 'coarseness' of this locking scheme
                    is  obviously  much  greater  than the first technique,
                    simultaneous  modification  of  a  particular secondary
                    index  would not be possible.  However, this limitation
                    may be offset by the following considerations:-


         RMS-11 Internals                                              Page 120





                    1.  Locking  is potentially a very expensive operation.
                        Successively to lock several multi-level indices in
                        which each index may have to be locked successively
                        from the root is an extremely painful operation.

                    2.  Contention  for secondary indices will be less than
                        for  the  primary  index.  (Note that this does not
                        mean that secondary indices will be used less, only
                        that  the  contention  at any point in time will be
                        less).

                    3.  All modifications to secondary indices are known 'a
                        priori'.  No locking across user calls is required.

                 ___________________________________________         g)      Subprogram Interfaces and Calling Sequences

                    "In  general the following conventions will be followed
                    for all internal components of RMS-11:

                    1.  All  calls  are  made  via  the  $CALL$ macro which
                        generates a JSR PC.

                    2.  Unless  noted  otherwise by a routine ALL registers
                        are preserved across a call.

                    3.  R5  is  used to point to the USER's input structure
                        (FAB, RAB etc.).

                    4.  R4  is  used  to  point to the primary SYSTEM input
                        structure (IFAB, IRAB etc.).

                    5.  R3 is used to point to the system impure area.

                    6.  The C-bit is used as a success or fail flag.

                    7.  No  condition  code  bits with the exception of the
                        C-bit  will  be  used  to  convey  input, output or
                        status information between routines.

                    8.  All  inputs,  outputs  and  status  information  is
                        conveyed  either  in structures (FAB, IRAB etc.) or
                        in Registers."

                 _________________________         h)      String Collating Sequence

                    "The  internal  representation  of  ASCII characters on
                    PDP-11  systems  is  7-bit  ASCII.   The string compare
                    routine  of  RMS-11, however, will perform a full 8-bit
                    unsigned  compare  per  character.    RMS-11  will  not
                    perform  any  'clear  bit  7'  code  on input or output
                    operations.  This will allow the support of user binary
                    byte strings, the KANA character set used in Japan, and
                    in  the future 8-bit ASCII when defined, without RMS-11
                    modifications  since  the  true  collating  sequence is
                    lowest character = 0, highest character = 255."

         RMS-11 Internals                                              Page 121






                 ________________________________________         i)      Unusual Conditions Treatment Philosophy.

                    "The  unusual  condition  treatment  philosophy  can be
                    summarized as follows:

                    1.  If  the operation can proceed, but at a decrease in
                        process/access  time  efficiency then continue, but
                        note if possible.

                    2.  If  the  operation  can  not proceed then abort the
                        operation.    Give  the  user the appropriate error
                        status.    Take  necessary  actions  to  insure the
                        integrity  of  the  file,  and  of  the system data
                        structures.

                    3.  The  insuring  of file integrity does not mean that
                        the  file is in the most efficient form for access,
                        but does mean that the file can be accessed.

                    4.  The  basic method of insuring file integrity during
                        output  operations  is  to perform the operation so
                        that if the system fails or a hard or logical error
                        is  detected  the  following  conditions are met in
                        their order by priority:

                        a.  No loss of data currently in the file.

                        b.  New  or  Updated  record  can  be found via the
                            Primary access path.

                        c.  Efficiency  of  random  access  to  the  new or
                            updated record via the primary access path.

                        d.  The efficiency of the secondary access paths.

                        e.  The correctness of the secondary access paths."


         RMS-11 Internals                                              Page 122





                                     __________                                     APPENDIX C

                  ________________________________________________                  Some RMS-11 Design/Logic Algorithms & Flowcharts

                 This  section  simply  contains  the  few  algorithms  and
                 flowcharts  contained  in  the RMS-11 Design/Logic Manual.
                 These  may be of interest to anyone attempting an in-depth
                 investigation of RMS-11.  All the material in this section
                 is copied verbatim from the manual.

                 ____________         1.      Bucket Split

                 The  following algorithm is used in order to determine the
                 'optimal'  point  at  which  to  split  a  bucket  when an
                 inserted record won't fit.

         1.1     Terminology

                 Slow    size  of all records in the bucket which are lower
                         in  collating  sequence than the new record.  This
                         record set is called Rlow.
                 Shigh   same  as  Slow,  but higher in collating sequence.
                         This record set is called Rhigh.
                 Snew    size of new record.
                 Srrv    Size of all current RRVs in the bucket.
                 Snrrv   Size  of  all  RRVs  which would be created if all
                         records in Rhigh were to be moved to a new bucket.
                 Smax    The maximum space available in an empty bucket.

         1.2     Basic Principles.

                 (Some  of  these  obviously must be traded off in order to
                 achieve a well-balanced algorithm.)

                 1.  The  number  of  new  RRVs  to be created (or updated)
                     should be minimized.
                 2.  Buckets should be roughly half-full after splitting.
                 3.  Excessive  effort  should  not  be  used  to  optimize
                     'unusual' situations.

         1.3     Algorithm

                 1.  Find  the place within the bucket at which Rnew should
                     go.
                 2.  Compute Slow, Shigh, Srrv, Snrrv.
                 3.  SUM = Slow + Srrv + Snrrv.
                     ["SUM"  represents  the  minimum amount of space which
                     must remain in this bucket.]
                 4.  [Now,  determine if Rnew can fit in this bucket if all
                     records in Rhigh were moved.]
                     If SUM + Snew > Smax goto step 11.

         RMS-11 Internals                                              Page 123





                 5.  [We  now  know that Rnew will fit in this bucket.  But
                     we  possibly  can  keep  some  of the records in Rhigh
                     also.]
                     If SUM + Snew > Smax/2 goto step 7.
                 6.  [Get the next record, Ri, from Rhigh.]
                     SUM = SUM + Si, goto step 5.
                 7.  If  SUM > Smax then SUM = SUM - Si & decrement pointer
                     past Ri.
                 8.  [We now know that Rlow, Rnew, and some of Rhigh should
                     stay in this bucket].
                     a.  Move  all  records from current pointer to the end
                         of data records to the new bucket.
                     b.  Move the other records in Rhigh down in the bucket
                         so as to allow Rnew to fit.
                 9.  Move old RRVs up.
                 10. DONE.
                 11. [The new record cannot fit with Rlow.  Maybe it can be
                     moved to the new bucket with Rhigh.]
                     If Snew + Shigh > Smax goto step 13.
                 12. Move  Rnew  to  the  new bucket; move Rhigh to the new
                     bucket; goto step 9.
                 13. [At  this  point,  the  new  record  will not fit with
                     either  subset of the records in the bucket.  So, give
                     up and put Rnew in its own bucket.]
                     Move  Rnew  to  new  bucket; move Rhigh to another new
                     bucket; goto step 9.
                     (The  move  of  Rnew is performed by a co-routine call
                     back  to  the  caller.   After the record is moved the
                     caller calls back SPLIT to continue the operation.)

                 ________________         2.      Record Insertion

                 The  following  is the basic algorithm for inserting a new
                 record into an Indexed organization file.
                 (The  positioning  for record insertions and the insertion
                 of  the  data  record's  address  (RRV)  in  the secondary
                 indices  has  been  altered from a 'first fit' scheme to a
                 FIFO  list scheme.  The major reason for this change is to
                 support the COBOL semantics for I/O.)

         2.1     Terminology

                 Ks      The  key  value  for  the  current  key  field  of
                         interest in the record to be inserted.
                 Ki      the key value for the i'th record in a bucket.
                 Ri      The i'th record in a bucket.
                 Rnew    The new record.

         2.1.1   Basic Search Rules

                 1.  Ki-1 Ki Ki+1
                     All  records  in  the  Ki  path  will  have key values
                     greater than Ki-1 but less than or equal to Ki.


         RMS-11 Internals                                              Page 124





                 2.  Horizontal Search rules.

                     Ks  <  K0  in  next bucket then search terminates past
                     last (Kl) record in current bucket.
                     Ks  >=  K0 in next bucket then search continues in the
                     next bucket (i.e. next bucket becomes current).

                 3.  Vertical Search rules.

                     Follow first path for which Ks = Ki.

                 4.  Insertion of data records with duplicate key values.

                     After the first exact match (Ks=Ki) then
                       When Ks > Ki stop positioning search
                        If Ki was K0 in the next bucket then position after
                       the  last  record  in current bucket.  (This ensures
                       that  we  will only be able to find records with key
                       values  of  Ks via one Ki in the lowest level of the
                       index.)

         2.2     Insert - Main Flow

                 The  following is the main flow for record insertion.  The
                 details  for  the  called  procedures will be found in the
                 following sections.

                 1.  [Setup  of  access  to  the  primary index so that the
                     user's data record may be inserted in the file.]

                 2.  [Follow  and  update  path  to  the data level for the
                     index.]

                     CALL FOLLOW-UPDATE-PATH
                     IF ERRORS THEN
                         IF ERROR IS NO INDEX THEN
                             MAKE INDEX
                             GO TO 2
                         END
                         RETURN
                     END
                     IF NOT AN EXACT MATCH FOR Ks THEN GO TO 4.

                 3.  [There  are records with the same key in the file.  If
                     this  is allowed then find the end of the records with
                     the same key.]

                     IF no duplicates are allowed THEN return error.
                     CALL POSITION-FOR-INSERT
                     IF ERRORS RETURN


         RMS-11 Internals                                              Page 125





                 4.  [We  are now positioned for where the record should be
                     inserted.]

                     RRV = 0 (indicate a new record)
                     CALL INSERT-RECORD
                     IF ERRORS RETURN
                     IF index update required CALL INDEX-UPDATE.

                 5.  [Record  is  now  inserted into the file.  We must now
                     insert  the  record in all the secondary indices.  The
                     data  for  the  secondary  indices  is the RRV for the
                     inserted data record.]

                     KREF = 1 (the first of the secondary indices)

                 6.  [Insert record into secondary index.]

                     WHILE KREF is less than or equal to the maximum key of
                     reference THEN
                         Setup for access to the index defined by KREF
                         CALL FOLLOW-UPDATE-PATH
                         IF ERRORS
                             IF ERROR IS NO INDEX THEN
                                 MAKE INDEX
                                 GO TO 6
                             END
                             GOTO 7
                         END
                         CALL INSERT-SECONDARY
                         IF ERRORS GO TO 7
                         IF index update required CALL INDEX-UPDATE
                         KREF = KREF + 1
                     END
                     DONE - RETURN

                 7.  [Hard  error condition detected during secondary index
                     insertion - delete record.]

                     CALL MARK-RRV-DELETED
                     RETURN ERROR


         RMS-11 Internals                                              Page 126





         2.3     Follow-Update-Path Procedure

                 The  follow  and  update  path procedure follows the index
                 tree  for the search key (Ks), and if needed updates index
                 records,  and  creates  a  new  index  record,  so that on
                 successful  completion we are positioned in the data level
                 at the record position associated with Ks.

                     INPUTS
                         Ks - the search key
                         The index descriptor
                     OUTPUTS
                         Path  through  index  updated  if  needed  and all
                         pointers etc. set up for record insertion.

                 1.  [Fetch the root bucket for the index.]

                 2.  [Follow  the  Index tree to level 1 - the lowest level
                     of the index.]

                     CALL Find-Index-Bucket (for level 1)
                     IF NOT FOUND THEN
                         IF bucket empty or past last entry THEN
                             IF past last THEN
                                 LET Klast = Ks
                             ELSE
                                 IF at level 1 THEN
                                     Allocate a data bucket
                                     Build index for Ks and data bucket
                                 ELSE
                                     RETURN WE HAVE A TREE ERROR
                                 END
                             END
                             GO TO 2
                         END
                         SYSTEM FAILURE - data base or code is damaged
                     END

                 3.  [Get the data bucket.]

                     CALL  Find-Data-Bucket (for Ks starting at Ri in Level
                                            1)
                     RETURN


         RMS-11 Internals                                              Page 127





         2.4     Position-for-Insert

                 This  procedure scans the records at the data level (level
                 0)  of  the  index  to find the place where the new record
                 Rnew should be inserted.

                     INPUTS
                         Ks = Knew, the search key
                         Ri = start position for search
                     OUTPUTS
                         Ri  =  the  record which logically follows Rnew in
                         the current bucket.

                 1.  [Find the end of the chain of records which have a key
                     value equal to Ks.]

                     WHILE Ks=Ki THEN
                         GET next record
                         IF no next record THEN
                             GET next bucket if none RETURN
                                 If Ks not equal to K0 THEN
                                     RETURN
                                 ELSE
                                     Change current bucket to next bucket
                                     Ri=R0 for next bucket
                                 END
                         END
                     END
                     RETURN


         RMS-11 Internals                                              Page 128





         2.5     Insert-Record

                 This  procedure inserts the user record Rnew before the Ri
                 record in the current bucket.

                     INPUTS
                         Rnew - record to be inserted
                         Ri - record which logically follows Rnew
                         Snew  -  size  of  the record to be inserted & all
                         overhead
                         RRV  -  the RRV of the record to be inserted, or 0
                         if a new record
                     OUTPUTS
                         RFA - the RFA of the inserted record
                         RRV - if RRV was 0 on entry it will be set to RFA

                         If  an index update is required then it is flagged
                         and all required data for the update is returned.

                 1.  [Does the record fit in the current bucket.]

                     IF Snew greater than the free space THEN

                         Garbage  collect  and  try  again.   If nothing to
                         collect  continue.  CALL SPLIT (co-routine set up)
                         (split  will  perform  the  operation specified in
                         Section  1,  and  will  return  all  required data
                         needed  to update the index and the RFA of the new
                         record.  After the split the Rlow record set is in
                         the  current  bucket  buffer, and the Rhigh record
                         set is in the next bucket buffer).

                         Move Rnew into bucket
                         If RRV is 0 then let RRV = RFA
                         Call back SPLIT
                     ELSE
                         Assign an RFA for the record
                         If RRV is 0 then let RRV=RFA
                         Spread data in bucket to make room for Rnew
                         Move Rnew into bucket (overhead+RRV+Rnew)
                     END


         RMS-11 Internals                                              Page 129





                 2.  [Update all RRVs.]

                     If bucket was split THEN
                         Write  out next bucket buffer (contains Rhigh) and
                         indicate  empty  but  frozen  (we  are  using next
                         bucket buffer as a work area).

                         [Scan the next bucket for all RRVs for the current
                         bucket  and  update  the associated RRV records in
                         the current bucket.]

                         LET CNT = the number of records in the next bucket
                         LET TMP = 0; LET I = 0
                         WHILE TMP not equal to CNT
                             If  record  not  done and bucket address of Ri
                             RRV  is  equal  to  the  current  bucket  then
                             update/create  RRV  record for Ri with its new
                             RFA in current bucket
                                 If Ri RRV equal RRV for new record THEN
                                     Flag new record's RRV updated
                                 END
                                 Mark Ri as done
                                 TMP = TMP + 1
                             ELSE
                                 If Ri is new record & no update needed
                                 THEN LET TMP = TMP + 1
                                 Mark Ri as done
                             END
                             I = I + 1
                             If  I  is  greater  than  CNT  (i.e. past last
                             record) THEN
                                 I = 0
                                 WHILE I is less than or equal to CNT
                                     If Ri has not been done THEN
                                         Get  bucket associated with Ri RRV
                                         and make it the current bucket
                                         I = 0
                                         LEAVE WHILE LOOP
                                     END
                                     I = I + 1
                                 END
                             END
                         END
                     END
                     IF new record RRV needs to be updated THEN
                         Get  bucket associated with RRV and update the RRV
                         record
                     END
                     RETURN


         RMS-11 Internals                                              Page 130





         2.6     Index-Update

                 This procedure starts at the root of the index and follows
                 the tree to level one.  It makes the required index record
                 insertions and updates.  If level one splits the procedure
                 is  executed  for level two.  If level two splits then the
                 procedure  is  executed  for  level  three  etc. up to and
                 including the generation of a new root.

                     INPUTS
                         Kohigh  -  new  high  key value for the old bucket
                         (the one that split) - output from SPLIT
                         Ks  -  the  search  key  (the key field in the new
                         record)
                         N - number of new buckets - output from SPLIT
                         Bn1 - new bucket one - output from SPLIT
                         Bn2 - new bucket two - output from SPLIT
                     OUTPUTS
                         Index update done

                 1.  [Setup for level 1.]

                     LEVEL = 1

                 2.  [Get to desired level in index.]

                     CALL Find-Index-Bucket (for LEVEL)
                     IF not found return error in structure

                 3.  [Calculate   the  size  required  for  the  new  index
                     record(s).]

                     S1 = Skey + SBn1;  S2 = 0
                     IF N=2 THEN S2 = Skey + SBn2

                 4.  [Is there room in this bucket.]

                     If S1 + S2 greater than available free space THEN
                         Allocate a new Index Bucket for this level (divide
                         index  records  so  that each index bucket will be
                         1/2 full)
                         SUM = 0; J = 0 (note Ri is the found index record)
                         WHILE SUM is less than 1/2 max free space
                             SUM = SUM + Sj
                             IF Rj = Ri THEN SUM = SUM + S1 + S2
                             J = J + 1
                         END
                         [Move required records to new bucket.]
                         Move Rj - Rlast to new bucket
                         IF J <= I THEN
                             [New records are to be placed in new bucket.]
                             Update Ri to position in new bucket
                         END
                         fix up all bucket overhead data
                         flag update required
                     END

         RMS-11 Internals                                              Page 131






                 5.  [We now have room to put new index record into.]

                     Spread  the data in the bucket so that the new records
                     can be built between Ri and Ri+1.

                     IF N = 1 THEN
                         Rnew1 = Ki, Bn1
                     ELSE
                         Rnew = Ks, Bn1
                         Rnew2 = Ki, Bn2
                     END
                     Ki = Kohigh

                 6.  [Additional updates required.]

                     IF update required THEN
                         update Kohigh; N=1; Bn1 = allocated bucket
                         IF we split the root THEN
                             Save  Khigh  for Bn1 (must have split on index
                             bucket not a data bucket)
                             Allocate  a  new  root bucket (use next bucket
                             buffer)
                             (Build index records in new root bucket)
                                 R0 = Khigh for current bucket, Bcurrent
                                 Ri = Khigh for Bn1, Bn1
                                 mark as root bucket
                                 set level field in bucket = LEVEL + 1
                                 write out old root bucket, update prologue
                                 mark  old  root as index bucket & write it
                                 out
                             Return
                         END
                         LEVEL = LEVEL + 1
                         GO TO 2
                     END
                     RETURN


         RMS-11 Internals                                              Page 132





         2.7     Insert-Secondary

                 This  procedure  performs  an  insert  of  the user's data
                 record's  RRV  into the data level of the secondary index.
                 The data records are pointer arrays for the key value.

                     INPUTS
                         Ks - the search key
                         Ri - start position in data level
                         RRV - the RRV of the user's data record
                     OUTPUTS
                         RRV  for  record  inserted  in  index and if index
                         update  is  required  then  it  is flagged and all
                         required data for the update is returned.

                 1.  [Did we find an exact match.]

                     IF Ks not equal to Ki then GO TO 4.
                     Rj = Ri
                     WHILE Ks = Ki THEN
                         Rj = Ri
                         Get next array record
                         IF no next array record THEN
                             GET next bucket - if none LEAVE WHILE LOOP
                             If Ks not equal to K0 then LEAVE WHILE LOOP
                             Change current bucket to next bucket
                             Ri = R0 for new bucket
                         END
                     END

                 2.  [We are now positioned at the last array segment Rj in
                     the array.]

                     IF  array pointer size is equal to or greater than the
                     RRV size THEN
                         IF array element can be expanded by one element
                             THEN add new element equal to RRV & return
                         END
                     END

                 3.  [Array  segment  pointer size is less than RRV size or
                     array can not be expanded.]

                     Ri = Rj+1 set up for insertion before Ri


         RMS-11 Internals                                              Page 133





                 4.  [Insert new array segment in bucket.]

                     (Calculate size of new array.)
                     Snew = overhead + Skey + Srrv
                     IF Snew > free space THEN
                         CALL SPLIT (co-routine setup)
                         Build new array in buffer via pointer from SPLIT
                         call back SPLIT
                     ELSE
                         spread data in bucket
                         build new array in bucket
                     END
                     RETURN


         RMS-11 Internals                                              Page 134





                 _____________________         3.      Functional Flowcharts

         3.1     $INIT

                 $RMSIN      Init Impure Area Pointers
                    !        Set SY$INI "RMS-Initialized" Flag
                    !        R0IMPA defines all pools globally
                    !
                 User Code   Return to User success/failure in C-bit



         3.2     $CREATE

                 R0CREA      $CREATE Control Routine
                   !
                 R0FSEI      Allocate and Initialize an IFAB
                   !         Link into IFAB chain in Impure Area (Y$IFAB)
                   !
                 R0FSET      Perform FAB field checks.
                   !         Set IFAB 'Busy'
                   !
                 COMMON      Org independent processing
                   !         Process file name (R0PRFN, R0XPFN)
                   !
                 R0IFLF      If TV=Non-0, invoke Org-specific module
                   !         If TV = 0, return ER$ENV error
                   !
                 CREATE      Org Specific Processing (R1CRFL...)
                   !         CREATE Validity Checks (R1CRCK...)
                   !         Org Independent Code (R0CRFL)
                   !         Org Dependent Code
                   !
                 R0RMSE      Common Exit Routine
                   !         Invoke User's Completion Routine if any
                   !         Set IFAB to 'Idle'
                   !
                 User Code   Return to User




         RMS-11 Internals                                              Page 135





         3.3     $OPEN

                 R0OPEN      $OPEN Control Module
                   !
                 R0FSEI      Allocate and Initialize an IFAB
                   !         Link into IFAB chain in Impure Area (Y$IFAB)
                   !
                 R0FSET      Perform FAB checks (BID, BLN ...)
                   !         Set IFAB 'busy'
                   !
                 COMMON      Process File Name (R0PRFN,R0XPFN)
                   !         Open Common Routines (R0OPFL)
                   !
                 R0IFLF      If TV=Non-0, call Org Specific Module
                   !         If TV=0 return ER$ENV error
                   !
                 OPEN        Org Specific Processing (R1OPFL ...)
                   !
                 R0DPYC      Display File Attributes into XAB chain
                   !
                 R0RMSE      Common Exit Routine
                   !         Invoke User's Completion Routine if any
                   !         Set IRAB to 'Idle'
                   !
                 User Code   Return to User



         3.4     $CONNECT

                 R0CONN      $CONNECT Control Module
                   !
                 R0RSEI      Allocate and Initialize an IRAB
                   !         Link into IRAB chain off IFAB (C$NIRB)
                   !
                 R0RSET      Perform RAB checks (BID, BLN ...)
                   !         Set IRAB 'busy'
                   !
                 CONNECT     Org Specific Processing (R1CONP ...)
                   !
                 R0RMSE      Common Exit Routine
                   !         Invoke User's Completion Routine if any
                   !         Set IRAB to 'Idle'
                   !
                 User Code   Return to User




         RMS-11 Internals                                              Page 136





         3.5     $GET

                 R0GET       $GET Control Routine
                   !
                 R0RSET      Perform RAB Field Checks (BID, BLN...)
                   !         Set IRAB 'Busy'
                   !
                  GET        Org specific processing (R3GET...)
                   !
                 R0RMSE      Common Exit Routine
                   !         Invoke User's Completion Routine if any
                   !         Set IRAB to 'Idle'
                   !
                 User Code   Return to User


                 (The  same  sort  of  path  is followed for $PUT, $UPDATE,
                 $DELETE,  $DISCONNECT,  $FIND,  $RELEASE,  $FREE,  $FLUSH,
                 $SPACE, $NXTVOL, $TRUNCATE, $REWIND, $READ, $WRITE.)



         3.6     $CLOSE

                 R0CLOS      $CLOSE Control Routine
                   !
                 R0FSET      Perform FAB field checks
                   !         Set IFAB 'Busy'
                   !
                 CLOSE       Org Specific Processing (R2CLOS...)
                   !
                 R0RMSE      Common Exit Routine
                   !         Invoke User's Completion Routine if any
                   !
                 User Code   Return to User



         3.7     $EXTEND

                 R0EXTE      $EXTEND Control Routine
                   !
                 R0FSET      Perform FAB field checks
                   !         Set IFAB 'Busy'
                   !
                 R0EXT0      Extend File Processing Module
                   !         Invokes R0EXTD for actual extend
                   !
                 R0RMSE      Common Exit Routine
                   !         Invoke User's Completion Routine if any
                   !         Set IFAB to 'Idle'
                   !
                 User Code   Return to User


         RMS-11 Internals                                              Page 137







         3.8     $DISPLAY

                 R0DISP      $DISPLAY Control Routine
                   !
                 R0FSET      Perform FAB field checks
                   !         Set IFAB 'Busy'
                   !
                 R0DPYC      Perform actual display of attributes
                   !         into XAB chain, if any
                   !
                 R0RMSE      Common Exit Routine
                   !         Invoke User's Completion Routine if any
                   !         Set IFAB to 'Idle'
                   !
                 User Code   Return to User



         3.9     $ERASE

                 R0ERAS      $ERASE Control Routine
                   !
                 R0FSEI      Allocate and Initialize an IFAB
                   !
                 R0FSET      Perform FAB field checks
                   !         Set IFAB 'Busy'
                   !
                 COMMON      Process File Name (R0PRFN, R0XPFN)
                   !
                 R0IFLF      If TV(R0ERAS) = Non-0 invoke Erase
                   !         If TV = 0 return ER$ENV error
                   !
                 R0ERFL      Actual Erase of the File
                   !
                 R0RMSE      Common Exit Routine
                   !         Invoke User's Completion Routine if any
                   !
                 User Code   Return to User



         RMS-11 Internals                                              Page 138





                                     __________                                     APPENDIX D

                              ________________________                              RMS-11 Mnemonic Glossary

                 As  has already been seen, much of RMS-11 processing under
                 MACRO-11  depends  on the three-character field mnemonics.
                 These  are well-defined in RMR, provided the user is aware
                 of  which structure they belong to.  However the following
                 table  may be useful, listing all such mnemonics, together
                 with  some information on the corresponding field (related
                 structure  type,  length  in bytes, RMR page reference and
                 brief description).

                 AID     ALLXAB  1   5-4   Area Identification Number
                 AIR     LCB     2   ***   Address of After-Image Routine
                 ALN     ALLXAB  1   5-5   Alignment Block Type
                 ALQ      -      4    -    Allocation Size
                 AOP     ALLXAB  1   5-9   Allocation Options
                 BID      -      1   -     Block Identifier
                 BIR     LCB     2   ***   Address of Before-Image Routine
                 BKS     FAB     1   3-6   Bucket Size
                 BKT     RAB     4   4-4   Bucket Number
                 BKZ     ALLXAB  1   5-10  Bucket Size
                 BLK     LCB     4   ***   Bucket Start VBN
                 BLN      -      1    -    Block Length
                 BLS     FAB     2   3-9   Magtape Block Size
                 BPA     FAB     2   3-11  Private Buffer Pool Address
                 BPS     FAB     2   3-13  Private Buffer Pool Size
                 BUF     LCB     2   ***   Buffer Address
                 CDT     DATXAB  8   5-22  Creation Date
                 COD      -      1    -    XAB type code
                 CTX      -      2    -    User Context Area
                 DAN     KEYXAB  1   5-31  Data Area Number
                 DBS     KEYXAB  1   5-33  Data Bucket Size
                 DCT     RAB     4   ***   Device Cluster
                 DEQ      -      2    -    Default Extension Quantity
                 DEV     FAB     1   3-19  Device Characteristics
                 DFL     KEYXAB  2   5-34  Data Bucket Fill Number
                 DID     NAM     6   ***   Directory ID
                 DNA     FAB     2   3-20  Default Name String Address
                 DNS     FAB     1   3-22  Default Name String Size
                 DTP     KEYXAB  1   5-36  Key Data Type
                 DVB     KEYXAB  4   5-38  Data Virtual Block Number
                 DVI     NAM     6   6-2   Device ID
                 EDT     DATXAB  8   ***   Expiration Date
                 ESA     NAM     2   6-3   Expanded String Address
                 ESL     NAM     1   6-4   Expanded String Length
                 ESS     NAM     1   6-5   Expanded String Buffer Size
                 FAB     RAB     2   4-7   FAB Address
                 FAC     FAB     1   3-23  File Access
                 FBDB    FAB     2   ***   Address of BDB after I/O
                 FID     NAM     6   6-6   File ID
                 FIOS    FAB     4   ***   Internal Status
                 FLG     KEYXAB  1   5-39  Key Attribute Flags

         RMS-11 Internals                                              Page 139





                 FNA     FAB     2   3-25  File Name Address
                 FNB     NAM     2   ***   Address of Filename Block
                 FNS     FAB     1   3-27  File Name Size
                 FOP     FAB     2   3-28  File Processing Options
                 FOVL    FAB     2   ***   Procedure Overlay Vector
                 FPAR    FAB     2   ***   Parameter List Pointer
                 FSZ     FAB     1   3-31  Fixed Control Area Size
                 FTn     FAB     2   ***   FAB Temporary Workspace (n=0-4)
                 HAL     KEYXAB  1   ***   Hashing Algorithm
                 IAN     KEYXAB  1   5-41  Index Area Number
                 IBS     KEYXAB  1   5-43  Index Bucket Size
                 IFI     FAB     2   3-33  Internal File Identifier
                 IFL     KEYXAB  2   5-44  Index Bucket Fill Number
                 ISI     RAB     2   4-9   Internal Stream Identifier
                 JNL     FAB     2   ***   Address of LCB
                 KBF     RAB     2   4-10  Key Buffer Address
                 KNM     KEYXAB  2   5-46  Key Name Address
                 KRF     RAB     1   4-12  Key of reference
                 KSZ     RAB     1   4-13  Key Size
                 LAN     KEYXAB  1   5-48  Lowest Index Level Area Number
                 LCH     FAB     1   3-34  Logical Channel
                 LOC     ALLXAB  4   5-16  Allocation Starting Point
                 LSZ     LCB     2   ***   Bucket Size
                 LVL     KEYXAB  1   5-50  Root Level
                 MBC     RAB     1   4-15  Multi-Block Count
                 MBF     RAB     1   4-17  Multi-Buffer Field
                 MRL     KEYXAB  2   5-51  Minimum Record Length
                 MRN     FAB     4   3-36  Maximum Record Number
                 MRS     FAB     2   3-38  Maximum Record Size
                 NAM     FAB     2   3-40  Name Block Address
                 NOA     SUMXAB  1   5-75  Number of Areas
                 NOK     SUMXAB  1   5-76  Number of Keys
                 NOR     SUMXAB  1   ***   Number of Record Descriptors
                 NSG     KEYXAB  1   5-52  Number of Key Segments
                 NUL     KEYXAB  1   5-53  Null Key Character
                 NXT      -      2    -    Link to next XAB
                 ORG     FAB     1   3-42  File Organisation
                 POS     KEYXAB  16  5-56  Key Positions
                 POSn    KEYXAB  2   5-57  Key Position (n=0-7)
                 PRG     PROXAB  2   5-68  Programmer Number
                 PRJ     PROXAB  2   5-69  Project Number
                 PRO     PROXAB  2   5-70  System File Protection Code
                 PVN     SUMXAB  2   5-78  Prologue Version Number
                 RAC     RAB     1   4-19  Record Access
                 RAT     FAB     1   3-43  Record Attributes
                 RBDB    RAB     2   ***   Address of BDB after I/O
                 RBF     RAB     2   4-20  Record Buffer Address
                 RDT     DATXAB  8   5-25  Revision Date
                 REF     KEYXAB  1   5-58  Key of Reference
                 RFA     RAB     6   4-22  Record's File Address
                 RFI     ALLXAB  6   ***   Related File ID
                 RFM     FAB     1   3-45  Record Format
                 RHB     RAB     2   4-23  Record Header Buffer Address
                 RIOS    RAB     4   ***   Internal Status

         RMS-11 Internals                                              Page 140





                 RLF     NAM     2   ***   Address of related FAB
                 ROP     RAB     2   4-25  Record Processing Options
                 ROVL    RAB     2   ***   Procedure Overlay Vector
                 RPAR    RAB     2   ***   Parameter List Pointer
                 RSA     NAM     2   ***   Resultant Filename Address
                 RSL     NAM     1   ***   Resultant Filename Length
                 RSS     NAM     1   ***   Resultant Filename Buffer Size
                 RSZ     RAB     2   4-28  Record Size
                 RTV     FAB     1   3-47  Retrieval Window Size
                 RTn     RAB     2   ***   RAB Temporary Workspace (n=0-10)
                 RT1A    RAB     1   ***   ?
                 RVB     KEYXAB  4   5-59  Root Virtual Block Number
                 RVN     DATXAB  2   5-26  Revision Number
                 SHR     FAB     1   3-51  File Sharing Options
                 SIZ     KEYXAB  8   5-60  Key Sizes
                 SIZn    KEYXAB  1   5-61  Key Size (n=0-7)
                 STS      -      2    -    Completion Status Code
                 STV      -      2    -    Additional Status Value
                 TKS     KEYXAB  1   5-63  Total Key Size
                 UBF     RAB     2   4-32  User Buffer Address
                 USZ     RAB     2   4-34  User Buffer Size
                 VOL     ALLXAB  2   5-19  Relative Volume Number
                 WCC     NAM     2   ***   Wild-card Context
                 XAB     FAB     2   3-25  XAB Address

                 Those  fields  with no structure name associated with them
                 are  common to more than one structure.  Those with a page
                 number of '***' are not described in RMR.

                 Note  that some of the field sizes given above differ from
                 those given in RMR - in general RMR is wrong.


